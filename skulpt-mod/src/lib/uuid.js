function $builtinmodule(){const{builtin:{bytes:l,str:u,int_:$,TypeError:h,ValueError:g,NotImplementedError:f,none:{none$:c},NotImplemented:{NotImplemented$:n}},abstr:{buildNativeClass:e,checkArgsLen:d,copyKeywordsToNamedArgs:w,lookupSpecial:r,setUpModuleMethods:t},misceval:{callsimArray:m,objectRepr:i,richCompareBool:b}}=Sk;var s={__name__:new u("uuid"),RESERVED_NCS:c,RFC_4122:c,RESERVED_FUTURE:c};let o=Sk.global.crypto;void 0===o&&(o={getRandomValues(e){let t=e.length;for(;t--;)e[t]=Math.floor(256*Math.random());return e}});const p=$.tp$getattr(new u("from_bytes")),a=$.tp$getattr(new u("to_bytes")),y=new $(1).nb$lshift(new $(128)),_=new $(0),v=new $(4),U=new $(16),E=new u("big"),S=new u("%032x"),R=/-/g;function k(){throw new f("Not yet implemneted in Skulpt")}function C(e){var t=new Uint8Array(e);return t[0]=e[3],t[1]=e[2],t[2]=e[1],t[3]=e[0],t[4]=e[5],t[5]=e[4],t[6]=e[7],t[7]=e[6],t}const I=s.UUID=e("uuid.UUID",{constructor:function(){},slots:{tp$init(e,t){d("UUID",e,0,6);let[n,r,i,s,o,,a]=w("UUID",["hex","bytes","bytes_le","fields","int","version","is_safe"],e,t,[c,c,c,c,c,c,c]);if(4!==[n,r,i,s,o].filter(e=>e===c).length)throw new h("one of the hex, bytes, bytes_le, fields, or int arguments must be given");if(n!==c){let e=0,t=(n=n.toString().replace("urn:","").replace("uuid:","")).length-1;for(;0<="{}".indexOf(n[e]);)e++;for(;0<="{}".indexOf(n[t]);)t--;if(32!==(n=(n=n.slice(e,t+1)).replace(R,"")).length)throw new g("badly formed hexadecimal UUID string");o=m($,[new u(n),U])}if(i!==c){if(!(i instanceof l))throw new h("bytes_le should be a bytes instance");if(16!==(i=i.valueOf()).length)throw new g("bytes_le is not a 16-char string");r=C(i),r=new l(r)}if(r!==c){if(!(r instanceof l))throw new h("bytes_le should be a bytes instance");if(16!==r.valueOf().length)throw new g("bytes is not a 16-char string");o=m(p,[r],["byteorder",E])}if(s!==c)throw new f("fields argument is not yet supported");if(o!==c&&(e=o,t=_,b(e,t,"Lt")||(e=o,t=y,b(e,t,"GtE"))))throw new g("int is out of range (need a 128-bit value)");this.$int=o,this.$isSafe=a},tp$str(){var e=S.nb$remainder(this.$int).toString();return new u(`${e.slice(0,8)}-${e.slice(8,12)}-${e.slice(12,16)}-${e.slice(16,20)}-`+e.slice(20))},$r(){var e=r(this.ob$type,u.$name),t=i(this.tp$str());return new u(e+`(${t})`)},tp$hash(){return this.$int.tp$hash()},tp$richcompare(e,t){return e instanceof I?this.$int.tp$richcompare(e.$int,t):n},tp$as_number:!0,nb$int(){return this.$int}},getsets:{int:{$get(){return this.$int}},is_safe:{$get(){return this.$isSafe}},bytes:{$get(){return m(a,[this.$int,U,E])}},bytes_le:{$get(){var e=this.tp$getattr(new u("bytes")).valueOf();return new l(C(e))}},fields:{$get(){return k()}},time_low:{$get(){return k()}},time_mid:{$get(){return k()}},time_hi_version:{$get(){return k()}},clock_seq_hi_variant:{$get(){return k()}},clock_seq_low:{$get(){return k()}},time:{$get(){return k()}},clock_seq:{$get(){return k()}},node:{$get(){return k()}},hex:{$get(){return S.nb$remainder(this.$int)}},urn:{$get(){return new u("urn:uuid:"+this)}},variant:{$get(){return k()}},version:{$get(){return k()}}}});return t("uuid",s,{uuid1:{$meth(){k()},$flags:{FastCall:!0}},uuid2:{$meth(){k()},$flags:{FastCall:!0}},uuid3:{$meth(){k()},$flags:{FastCall:!0}},uuid4:{$meth(){var e=new l(o.getRandomValues(new Uint8Array(16)));return m(I,[],["bytes",e,"version",v])},$flags:{NoArgs:!0}},uuid5:{$meth(){k()},$flags:{FastCall:!0}}}),s}