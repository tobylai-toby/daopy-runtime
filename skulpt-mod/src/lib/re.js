function $builtinmodule(name){const{builtin:{dict:pyDict,str:pyStr,list:pyList,int_:pyInt,type:pyType,tuple:pyTuple,mappingproxy:pyMappingProxy,slice:pySlice,none:{none$:pyNone},NotImplemented:{NotImplemented$:pyNotImplemented},Exception,OverflowError,IndexError,TypeError,ValueError,checkInt,checkString,checkCallable,hex},abstr:{buildNativeClass,typeName,checkOneArg,numberBinOp,copyKeywordToNamedArgs,setUpModuleMethods},misceval:{iterator:pyIterator,objectRepr,asIndexSized,isIndex,callsimArray:pyCall}}=Sk,re={__name__:new pyStr("re"),__all__:new pyList(["match","fullmatch","search","sub","subn","split","findall","finditer","compile","purge","template","escape","error","Pattern","Match","A","I","L","M","S","X","U","ASCII","IGNORECASE","LOCALE","MULTILINE","DOTALL","VERBOSE","UNICODE"].map(e=>new pyStr(e)))},_value2member={},RegexFlagMeta=buildNativeClass("RegexFlagMeta",{constructor:function(){},base:pyType,slots:{tp$iter(){const e=Object.values(_members)[Symbol.iterator]();return new pyIterator(()=>e.next().value)},sq$contains(e){if(e instanceof this)return Object.values(_members).includes(e);throw new TypeError("unsupported operand type(s) for 'in': '"+typeName(e)+"' and '"+typeName(this)+"'")}}}),_members=(re.RegexFlag=buildNativeClass("RegexFlag",{meta:RegexFlagMeta,base:pyInt,constructor:function(e){var t=_value2member[e];if(t)return t;this.v=e,_value2member[e]=this},slots:{tp$new(e,t){checkOneArg("RegexFlag",e,t);t=e[0].valueOf();if(checkInt(t))return new re.RegexFlag(t);throw new ValueError(objectRepr(t)+" is not a valid RegexFlag")},$r(){let r=this.valueOf();var e=r<0;r=e?~r:r;const n=[];Object.entries(_members).forEach(([e,t])=>{t=t.valueOf();r&t&&(r&=~t,n.push("re."+e))}),r&&n.push(hex(r).toString());let t=n.join("|");return e&&(t=1<n.length?"~("+t+")":"~"+t),new pyStr(t)},sq$contains(e){if(e instanceof re.RegexFlag)return this.nb$and(e)===e;throw new TypeError("'in' requires a RegexFlag not "+typeName(e))},nb$and:flagBitSlot((e,t)=>e&t,JSBI.bitwiseAnd),nb$or:flagBitSlot((e,t)=>e|t,JSBI.bitwiseOr),nb$xor:flagBitSlot((e,t)=>e^t,JSBI.bitwiseXor),nb$invert:function(){var e=this.v;return"number"==typeof e?new re.RegexFlag(~e):new re.RegexFlag(JSBI.bitwiseNot(e))}},proto:{valueOf(){return this.v}},flags:{sk$unacceptableBase:!0}}),re.TEMPLATE=re.T=new re.RegexFlag(1),re.IGNORECASE=re.I=new re.RegexFlag(2),re.LOCALE=re.L=new re.RegexFlag(4),re.MULTILINE=re.M=new re.RegexFlag(8),re.DOTALL=re.S=new re.RegexFlag(16),re.UNICODE=re.U=new re.RegexFlag(32),re.VERBOSE=re.X=new re.RegexFlag(64),re.DEBUG=new re.RegexFlag(128),re.ASCII=re.A=new re.RegexFlag(256),{ASCII:re.A,IGNORECASE:re.I,LOCALE:re.L,UNICODE:re.U,MULTILINE:re.M,DOTALL:re.S,VERBOSE:re.X,TEMPLATE:re.T,DEBUG:re.DEBUG});function flagBitSlot(n,e){return function(t){if(t instanceof re.RegexFlag||t instanceof pyInt){var r=this.v,t=t.v;if("number"!=typeof r||"number"!=typeof t)return r=JSBI.BigUp(r),t=JSBI.BigUp(t),new re.RegexFlag(JSBI.numberIfSafe(e(r,t)));{let e=n(r,t);return e<0&&(e+=4294967296),new re.RegexFlag(e)}}return pyNotImplemented}}const jsFlags={i:re.I,m:re.M,s:re.S,u:re.U},jsInlineFlags={i:re.I,a:re.A,s:re.S,L:re.L,m:re.M,u:re.U,x:re.X},flagFails=(RegExp.prototype.hasOwnProperty("sticky")||delete jsFlags.s,RegExp.prototype.hasOwnProperty("unicode")||delete jsFlags.u,Object.entries({"cannot use LOCALE flag with a str pattern":re.L,"ASCII and UNICODE flags are incompatible":new re.RegexFlag(re.A.valueOf()|re.U.valueOf())})),inline_regex=/\(\?([isamux]+)\)/g;function adjustFlags(e,r){let t=e.toString(),n="g",s=0;return t=t.replace(inline_regex,(e,t)=>{for(var r of t){r=jsInlineFlags[r];s|=r.valueOf()}return""}),flagFails.forEach(([e,t])=>{if((t.valueOf()&s)===t.valueOf())throw new re.error("bad bad inline flags: "+e)}),r=numberBinOp(new re.RegexFlag(s),r,"BitOr"),flagFails.forEach(([e,t])=>{if(numberBinOp(t,r,"BitAnd")===t)throw new ValueError(e)}),numberBinOp(re.A,r,"BitAnd")!==re.A&&(r=numberBinOp(re.U,r,"BitOr")),Object.entries(jsFlags).forEach(([e,t])=>{numberBinOp(t,r,"BitAnd")===t&&(n+=e)}),r=new re.RegexFlag(r.valueOf()),[t,n,r]}let neg_lookbehind_A="(?<!\\\\n)";!function checkLookBehindSupport(){try{(1,eval)("/(?<!foo)/")}catch{neg_lookbehind_A=""}}();const initialUnescapedBracket=/([^\\])(\[\^?)\](\]|.*[^\\]\])/g,py_to_js_regex=/([^\\])({,|\\A|\\Z|\$|\(\?P=([^\d\W]\w*)\)|\(\?P<([^\d\W]\w*)>)(?!(?:\]|[^\[]*[^\\]\]))/g,py_to_js_unicode_escape=/\\[\t\r\n \v\f#&~"'!:,;`<>]|\\-(?!(?:\]|[^\[]*[^\\]\]))/g,quantifierErrors=/Incomplete quantifier|Lone quantifier/g,_compiled_patterns=Object.create(null);function compile_pattern(a,e){let t,r;[t,r,e]=adjustFlags(a,e);var n=_compiled_patterns[a.toString()];if(n&&n.$flags===e)return n;const o={};let s,i,l=t=(t=(t=(t="_"+t).replace(initialUnescapedBracket,"$1$2\\]$3")).replace(py_to_js_regex,(e,t,r,n,s,i)=>{switch(r){case"\\A":return t+neg_lookbehind_A+"^";case"\\Z":return t+"$(?!\\n)";case"{,":return t+"{0,";case"$":return t+"(?:(?=\\n$)|$)";default:if(r.endsWith(">"))return o[s]=!0,t+"(?<"+s+">";if(o[n])return t+"\\k<"+n+">";throw new re.error("unknown group name "+n+" at position "+i+1,a,new pyInt(i+1))}})).slice(1);r.includes("u")&&(l=t.replace(py_to_js_unicode_escape,e=>{switch(e){case"\\ ":return" ";case"\\\t":return"\\t";case"\\\n":return"\\n";case"\\\v":return"\\v";case"\\\f":return"\\f";case"\\r":return"\\r";default:return e.slice(1)}}));try{s=new RegExp(l,r)}catch(e){if(!quantifierErrors.test(e.message))throw i=e.message.substring(e.message.lastIndexOf(":")+2)+" in pattern: "+a.toString(),new re.error(i,a);try{s=new RegExp(t,r.replace("u",""))}catch(e){throw i=e.message.substring(e.message.lastIndexOf(":")+2)+" in pattern: "+a.toString(),new re.error(i,a)}}n=new re.Pattern(s,a,e);return _compiled_patterns[a.toString()]=n}function _compile(e,t){if(e instanceof re.Pattern){if(t!==zero||t.valueOf())throw new ValueError("cannot process flags argument with compiled pattern");return e}if(checkString(e))return compile_pattern(e,t);throw new TypeError("first argument must be string or compiled pattern")}re.error=buildNativeClass("re.error",{base:Exception,constructor:function(e,t,r){this.$pattern=t,this.$msg=e,this.$pos=r||pyNone,Exception.call(this,e)},slots:{tp$doc:"Exception raised for invalid regular expressions.\n\n    Attributes:\n\n        msg: The unformatted error message\n        pattern: The regular expression pattern\n",tp$init(e,t){var[e,t,r]=copyKeywordToNamedArgs("re.error",["msg","pattern","pos"],e,t,[pyNone,pyNone]);this.$pattern=t,this.$pos=r,this.$msg=e}},getsets:{msg:{$get(){return this.$msg}},pattern:{$get(){return this.$pattern}},pos:{$get(){return this.$pos}}}});const zero=new pyInt(0),maxsize=Number.MAX_SAFE_INTEGER,escape_chrs=(re.Pattern=buildNativeClass("re.Pattern",{constructor:function(e,t,r){this.v=e,this.str=t,this.$flags=r,this.$groups=null,this.$groupindex=null},slots:{$r(){var e=objectRepr(this.str).slice(0,200),t=objectRepr(this.$flags.nb$and(re.U.nb$invert()));return new pyStr("re.compile("+e+(t?", "+t:"")+")")},tp$richcompare(e,t){return("Eq"===t||"NotEq"===t)&&e instanceof re.Pattern?(e=this.str===e.str&&this.$flags===e.$flags,"Eq"===t?e:!e):pyNotImplemented},tp$hash(){},tp$doc:"Compiled regular expression object."},methods:{match:{$meth:function(e,t,r){return this.$match(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:"Matches zero or more characters at the beginning of the string."},fullmatch:{$meth:function(e,t,r){return this.full$match(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:"Matches against all of the string."},search:{$meth:function(e,t,r){return this.$search(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:"Scan through string looking for a match, and return a corresponding match object instance.\n\nReturn None if no position in the string matches."},sub:{$meth:function(e,t,r){return this.$sub(e,t,r)},$flags:{NamedArgs:["repl","string","count"],Defaults:[zero]},$textsig:"($self, /, repl, string, count=0)",$doc:"Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl."},subn:{$meth:function(e,t,r){return this.$subn(e,t,r)},$flags:{NamedArgs:["repl","string","count"],Defaults:[zero]},$textsig:"($self, /, repl, string, count=0)",$doc:"Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl."},findall:{$meth:function(e,t,r){return this.find$all(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:"Return a list of all non-overlapping matches of pattern in string."},split:{$meth:function(e,t){return this.$split(e,t)},$flags:{NamedArgs:["string","maxsplit"],Defaults:[zero]},$textsig:"($self, /, string, maxsplit=0)",$doc:"Split string by the occurrences of pattern."},finditer:{$meth:function(e,t,r){return this.find$iter(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:"Return an iterator over all non-overlapping matches for the RE pattern in string.\n\nFor each match, the iterator returns a match object."},scanner:{$meth:function(e,t,r){return this.$scanner(e,t,r)},$flags:{NamedArgs:["string","pos","endpos"],Defaults:[zero,maxsize]},$textsig:"($self, /, string, pos=0, endpos=sys.maxsize)",$doc:null},__copy__:{$meth:function(){return this},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:null},__deepcopy__:{$meth:function(){return this},$flags:{OneArg:!0},$textsig:"($self, memo, /)",$doc:null}},getsets:{pattern:{$get(){return this.str},$doc:"The pattern string from which the RE object was compiled."},flags:{$get(){return this.$flags},$doc:"The regex matching flags."},groups:{$get(){var e;return null===this.$groups&&(e=(this.str.v.match(this.group$regex)||[]).length,this.$groups=new pyInt(e)),this.$groups},$doc:"The number of capturing groups in the pattern."},groupindex:{$get(){if(null===this.$groupindex){var t=[];let e=1;for(const r of this.str.v.matchAll(this.group$regex))r[1]&&(t.push(new pyStr(r[1])),t.push(new pyInt(e))),e++;this.$groupindex=new pyMappingProxy(new pyDict(t))}return this.$groupindex},$doc:"A dictionary mapping group names to group numbers."}},proto:{group$regex:/\((?!\?(?!P<).*)(?:\?P<([^\d\W]\w*)>)?(?![^\[]*\])/g,get$count(e){return(e=asIndexSized(e,OverflowError))||Number.POSITIVE_INFINITY},get$jsstr(e,t,r){if(checkString(e))return t===zero&&r===maxsize||void 0===t&&void 0===r?{jsstr:e.toString(),pos:zero.valueOf(),endpos:e.sq$length()}:({start:t,end:r}=pySlice.startEnd$wrt(e,t,r),{jsstr:e.toString().slice(t,r),pos:t,endpos:r});throw new TypeError("expected string or bytes-like object")},find$all(e,t,r){var n,e=this.get$jsstr(e,t,r)["jsstr"],t=this.v,s=[];for(n of e.matchAll(t))s.push(1===n.length?new pyStr(n[0]):2===n.length?new pyStr(n[1]):new pyTuple(n.slice(1).map(e=>new pyStr(e))));return new pyList(s)},$split(e,t){t=(t=asIndexSized(t))||Number.POSITIVE_INFINITY;let r=this.get$jsstr(e)["jsstr"];var n,s=this.v,i=[];let a=0,o=0;for(;null!==(n=s.exec(r))&&a<t;)if(i.push(new pyStr(r.substring(o,n.index))),1<n.length&&i.push(...n.slice(1).map(e=>void 0===e?pyNone:new pyStr(e))),a++,o=s.lastIndex,n.index===s.lastIndex){if(!r)break;r=r.slice(n.index),o=0,s.lastIndex=1}return s.lastIndex=0,i.push(new pyStr(r.slice(o))),new pyList(i)},match$from_repl(e,t,r,n){let s;var i=e[e.length-1];return"object"==typeof i?(s=e.slice(0,e.length-3),Object.assign(s,{groups:i}),s.index=e[e.length-3]):((s=e.slice(0,e.length-2)).groups=void 0,s.index=e[e.length-2]),new re.Match(s,this.str,t,r,n)},do$sub(t,r,n){const{jsstr:e,pos:s,endpos:i}=this.get$jsstr(r);let a,o=(a=checkCallable(t)?e=>{e=pyCall(t,[e]);if(checkString(e))return e.toString();throw new TypeError("expected str instance, "+typeName(e)+" found")}:(t=this.get$jsstr(t).jsstr,e=>e.template$repl(t)),n=this.get$count(n),0);var l=e.replace(this.v,(...e)=>{if(o>=n)return e[0];o++;e=this.match$from_repl(e,r,s,i);return a(e)});return[new pyStr(l),new pyInt(o)]},$sub(e,t,r){var[e]=this.do$sub(e,t,r);return e},$subn(e,t,r){return new pyTuple(this.do$sub(e,t,r))},do$match(e,t,r,n){({jsstr:s,pos:r,endpos:n}=this.get$jsstr(t,r,n));var s=s.match(e);return null===s?pyNone:new re.Match(s,this,t,r,n)},$search(e,t,r){var n=new RegExp(this.v.source,this.v.flags.replace("g",""));return this.do$match(n,e,t,r)},$match(e,t,r){var n=this.v.source,s=this.v.flags.replace("g","").replace("m",""),n="^"+n,n=new RegExp(n,s);return this.do$match(n,e,t,r)},full$match(e,t,r){var n=this.v.source,s=this.v.flags.replace("g","").replace("m",""),n="^(?:"+n+")$",n=new RegExp(n,s);return this.do$match(n,e,t,r)},find$iter(t,r,n){var e;({jsstr:e,pos:r,endpos:n}=this.get$jsstr(t,r,n));const s=e.matchAll(this.v);return new pyIterator(()=>{var e=s.next().value;if(void 0!==e)return new re.Match(e,this,t,r,n)})}},flags:{sk$unacceptableBase:!0}}),re.Match=buildNativeClass("re.Match",{constructor:function(e,t,r,n,s){this.v=e,this.$match=new pyStr(this.v[0]),this.str=r,this.$re=t,this.$pos=n,this.$endpos=s,this.$groupdict=null,this.$groups=null,this.$lastindex=null,this.$lastgroup=null,this.$regs=null},slots:{tp$doc:"The result of re.match() and re.search().\nMatch objects always have a boolean value of True.",$r(){var e="<re.Match object; ",e=(e+="span=("+this.v.index+", "+(this.v.index+this.$match.sq$length())+"), ")+("match="+objectRepr(this.$match)+">");return new pyStr(e)},tp$as_squence_or_mapping:!0,mp$subscript(e){e=this.get$group(e);return void 0===e?pyNone:new pyStr(e)}},methods:{group:{$meth:function(...e){let t;return e.length<=1?void 0===(t=this.get$group(e[0]))?pyNone:new pyStr(t):(t=[],e.forEach(e=>{e=this.get$group(e),t.push(void 0===e?pyNone:new pyStr(e))}),new pyTuple(t))},$flags:{MinArgs:0},$textsig:null,$doc:"group([group1, ...]) -> str or tuple.\n    Return subgroup(s) of the match by indices or names.\n    For 0 returns the entire match."},start:{$meth:function(e){e=this.get$group(e);return void 0===e?new pyInt(-1):new pyInt(this.str.v.indexOf(e,this.v.index+this.$pos))},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, group=0, /)",$doc:"Return index of the start of the substring matched by group."},end:{$meth:function(e){e=this.get$group(e);return void 0===e?new pyInt(-1):new pyInt(this.str.v.indexOf(e,this.v.index+this.$pos)+[...e].length)},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, group=0, /)",$doc:"Return index of the end of the substring matched by group."},span:{$meth:function(e){return this.$span(e)},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, group=0, /)",$doc:"For match object m, return the 2-tuple (m.start(group), m.end(group))."},groups:{$meth:function(t){return null===this.$groups&&(this.$groups=Array.from(this.v.slice(1),e=>void 0===e?t:new pyStr(e)),this.$groups=new pyTuple(this.$groups)),this.$groups},$flags:{NamedArgs:["default"],Defaults:[pyNone]},$textsig:"($self, /, default=None)",$doc:"Return a tuple containing all the subgroups of the match, from 1.\n\n  default\n    Is used for groups that did not participate in the match."},groupdict:{$meth:function(r){if(null===this.$groupdict)if(void 0===this.v.groups)this.$groupdict=new pyDict;else{const n=[];Object.entries(this.v.groups).forEach(([e,t])=>{n.push(new pyStr(e)),n.push(void 0===t?r:new pyStr(t))}),this.$groupdict=new pyDict(n)}return this.$groupdict},$flags:{NamedArgs:["default"],Defaults:[pyNone]},$textsig:"($self, /, default=None)",$doc:"Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n\n  default\n    Is used for groups that did not participate in the match."},expand:{$meth:function(e){if(checkString(e))return e=e.toString(),e=this.template$repl(e),new pyStr(e);throw new TypeError("expected str instance got "+typeName(e))},$flags:{OneArg:!0},$textsig:"($self, /, template)",$doc:"Return the string obtained by doing backslash substitution on the string template, as done by the sub() method."},__copy__:{$meth:function(){return this},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:null},__deepcopy__:{$meth:function(){return this},$flags:{OneArg:!0},$textsig:"($self, memo, /)",$doc:null}},getsets:{lastindex:{$get(){if(null===this.$lastindex){let r=0,n;this.v.forEach((e,t)=>{t&&void 0!==e&&n!==e&&(r=t,n=e)}),this.$lastindex=r?new pyInt(r):pyNone}return this.$lastindex},$doc:"The integer index of the last matched capturing group."},lastgroup:{$get(){if(null===this.$lastgroup)if(void 0===this.v.groups)this.$lastgroup=pyNone;else{let r;Object.entries(this.v.groups).forEach(([e,t])=>{void 0!==t&&(r=e)}),this.$lastgroup=void 0===r?pyNone:new pyStr(r)}return this.$lastgroup},$doc:"The name of the last matched capturing group."},regs:{$get(){if(null===this.$regs){const r=[];this.v.forEach((e,t)=>{r.push(this.$span(t))}),this.$regs=new pyTuple(r)}return this.$regs}},string:{$get(){return this.str},$doc:"The string passed to match() or search()."},re:{$get(){return this.$re},$doc:"The regular expression object."},pos:{$get(){return new pyInt(this.$pos)},$doc:"The index into the string at which the RE engine started looking for a match."},endpos:{$get(){return new pyInt(this.$endpos)},$doc:"The index into the string beyond which the RE engine will not go."}},proto:{get$group(e){if(void 0===e)return this.v[0];if(checkString(e)){if(e=e.toString(),this.v.groups&&Object.prototype.hasOwnProperty.call(this.v.groups,e))return this.v.groups[e]}else if(isIndex(e)&&0<=(e=asIndexSized(e))&&e<this.v.length)return this.v[e];throw new IndexError("no such group")},$span(e){e=this.get$group(e);if(void 0===e)return new pyTuple([new pyInt(-1),new pyInt(-1)]);let t;return""===e&&""===this.v[0]?(t=new pyInt(this.v.index),new pyTuple([t,t])):(t=this.str.v.indexOf(e,this.v.index+this.$pos),new pyTuple([new pyInt(t),new pyInt(t+[...e].length)]))},hasOwnProperty:Object.prototype.hasOwnProperty,template$regex:/\\([1-9][0-9]|[1-9])|\\g<([1-9][0-9]*)>|\\g<([^\d\W]\w*)>|\\g<?.*>?/g,template$repl(e){return e.replace(this.template$regex,(e,t,r,n,s,i)=>{let a;if(void 0!==(t=t||r)?a=t<this.v.length?this.v[t]||"":void 0:this.v.groups&&this.hasOwnProperty.call(this.v.groups,n)&&(a=this.v.groups[n]||""),void 0!==a)return a;if(n)throw new IndexError("unknown group name '"+n+"'");throw new re.error("invalid group reference "+(t||e.slice(2))+" at position "+(s+1))})}},flags:{sk$unacceptableBase:!0}}),setUpModuleMethods("re",re,{match:{$meth:function(e,t,r){return _compile(e,r).$match(t)},$flags:{NamedArgs:["pattern","string","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, string, flags=0)",$doc:"Try to apply the pattern at the start of the string, returning\n    a Match object, or None if no match was found."},fullmatch:{$meth:function(e,t,r){return _compile(e,r).full$match(t)},$flags:{NamedArgs:["pattern","string","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, string, flags=0)",$doc:"Try to apply the pattern to all of the string, returning\n    a Match object, or None if no match was found."},search:{$meth:function(e,t,r){return _compile(e,r).$search(t)},$flags:{NamedArgs:["pattern","string","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, string, flags=0)",$doc:"Scan through string looking for a match to the pattern, returning\n    a Match object, or None if no match was found."},sub:{$meth:function(e,t,r,n,s){return _compile(e,s).$sub(t,r,n)},$flags:{NamedArgs:["pattern","repl","string","count","flags"],Defaults:[zero,zero]},$textsig:"($module, / , pattern, string, count=0, flags=0)",$doc:"Return the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in string by the\n    replacement repl.  repl can be either a string or a callable;\n    if a string, backslash escapes in it are processed.  If it is\n    a callable, it's passed the Match object and must return\n    a replacement string to be used."},subn:{$meth:function(e,t,r,n,s){return _compile(e,s).$subn(t,r,n)},$flags:{NamedArgs:["pattern","repl","string","count","flags"],Defaults:[zero,zero]},$textsig:"($module, / , pattern, string, count=0, flags=0)",$doc:"Return a 2-tuple containing (new_string, number).\n    new_string is the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in the source\n    string by the replacement repl.  number is the number of\n    substitutions that were made. repl can be either a string or a\n    callable; if a string, backslash escapes in it are processed.\n    If it is a callable, it's passed the Match object and must\n    return a replacement string to be used."},split:{$meth:function(e,t,r,n){return _compile(e,n).$split(t,r)},$flags:{NamedArgs:["pattern","string","maxsplit","flags"],Defaults:[zero,zero]},$textsig:"($module, / , pattern, string, maxsplit=0, flags=0)",$doc:"Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.  If\n    capturing parentheses are used in pattern, then the text of all\n    groups in the pattern are also returned as part of the resulting\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\n    and the remainder of the string is returned as the final element\n    of the list."},findall:{$meth:function(e,t,r){return _compile(e,r).find$all(t)},$flags:{NamedArgs:["pattern","string","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, string, flags=0)",$doc:"Return a list of all non-overlapping matches in the string.\n\n    If one or more capturing groups are present in the pattern, return\n    a list of groups; this will be a list of tuples if the pattern\n    has more than one group.\n\n    Empty matches are included in the result."},finditer:{$meth:function(e,t,r){return _compile(e,r).find$iter(t)},$flags:{NamedArgs:["pattern","string","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, string, flags=0)",$doc:"Return an iterator over all non-overlapping matches in the\n    string.  For each match, the iterator returns a Match object.\n\n    Empty matches are included in the result."},compile:{$meth:function(e,t){return _compile(e,t)},$flags:{NamedArgs:["pattern","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, flags=0)",$doc:"Compile a regular expression pattern, returning a Pattern object."},purge:{$meth:function(){return Object.keys(_compiled_patterns).forEach(e=>{delete _compiled_patterns[e]}),pyNone},$flags:{NoArgs:!0},$textsig:"($module, / )",$doc:"Clear the regular expression caches"},template:{$meth:function(e,t){return _compile(e,numberBinOp(re.T,t,"BitOr"))},$flags:{NamedArgs:["pattern","flags"],Defaults:[zero]},$textsig:"($module, / , pattern, flags=0)",$doc:"Compile a template pattern, returning a Pattern object"},escape:{$meth:function(e){if(checkString(e))return e=(e=e.toString()).replace(escape_chrs,"\\$&"),new pyStr(e);throw new TypeError("expected a str instances, got "+typeName(e))},$flags:{NamedArgs:["pattern"],Defaults:[]},$textsig:"($module, / , pattern)",$doc:"\n    Escape special characters in a string.\n    "}}),/[\&\~\#.*+\-?^${}()|[\]\\\t\r\v\f\n ]/g);return re}