function $builtinmodule(){const e={};return Sk.misceval.chain(Sk.importModule("collections",!1,!0),t=>(e._namedtuple=t.$d.namedtuple,functools_mod(e)))}function functools_mod(s){const{object:a,int_:t,str:o,list:e,tuple:i,dict:c,none:{none$:_},bool:{false$:h},NotImplemented:{NotImplemented$:C},bool:D,func:u,method:M,TypeError:p,RuntimeError:O,ValueError:W,NotImplementedError:U,AttributeError:l,OverflowError:d,checkNone:f,checkBool:G,checkCallable:g,checkClass:B}=Sk.builtin,{callsimArray:w,callsimOrSuspendArray:m,iterFor:F,chain:$,isIndex:y,asIndexSized:b,isTrue:k,richCompareBool:r,objectRepr:v,retryOptionalSuspeionOrThrow:K,chain:L}=Sk.misceval,x=Sk.ffi["remapToPy"],{checkOneArg:V,checkNoKwargs:H,buildNativeClass:n,setUpModuleMethods:J,keywordArrayFromPyDict:A,keywordArrayToPyDict:S,objectHash:Q,lookupSpecial:X,copyKeywordsToNamedArgs:E,typeName:N,objectSetItem:Y,iter:P,gattr:R}=Sk.abstr;var{getSetDict:j,getAttr:Z,setAttr:tt}=Sk.generic;function et(t){return new u(()=>{throw new U(t+" is not yet implemented in skulpt")})}Object.assign(s,{__name__:new o("functools"),__doc__:new o("Tools for working with functions and callable objects"),__all__:new e(["update_wrapper","wraps","WRAPPER_ASSIGNMENTS","WRAPPER_UPDATES","total_ordering","cmp_to_key","cache","lru_cache","reduce","partial","partialmethod","singledispatch","singledispatchmethod","cached_property"].map(t=>new o(t))),WRAPPER_ASSIGNMENTS:new i(["__module__","__name__","__qualname__","__doc__","__annotations__"].map(t=>new o(t))),WRAPPER_UPDATES:new i([new o("__dict__")]),singledispatch:et("singledispatch"),singledispatchmethod:et("singledispatchmethod")});const nt=new o("cache_parameters");function rt(n,r){if(r=r||h,y(n))(n=b(n,d))<0&&(n=0);else{var t,e;if(g(n)&&G(r))return t=n,n=128,(e=new z(t,n,r)).tp$setattr(nt,new u(()=>x({maxsize:n,typed:r}))),m(s.update_wrapper,[e,t]);if(!f(n))throw new p("Expected first argument to be an integer, a callable, or None")}return new u(t=>{var e=new z(t,n,r);return e.tp$setattr(nt,new u(()=>x({maxsize:n,typed:r}))),m(s.update_wrapper,[e,t])})}const st=s._CacheInfo=w(s._namedtuple,["CacheInfo",["hits","misses","maxsize","currsize"]].map(t=>x(t)),["module",new o("functools")]),z=n("functools._lru_cache_wrapper",{constructor:function(t,e,n,r){if(!g(t))throw new p("the first argument must be callable");let s;if(f(e))s=at,e=-1;else{if(!y(e))throw new p("maxsize should be integer or None");(e=b(e,d))<0&&(e=0),s=0===e?it:ot}this.root={},this.root.prev=this.root.next=this.root,this.wrapper=s,this.maxsize=e,this.typed=n,this.cache=new c([]),this.func=t,this.misses=this.hits=0,this.$d=new c([])},slots:{tp$new(t,e){var[t,e,n,r]=E("_lru_cache_wrapper",["user_function","maxsize","typed","cache_info_type"],t,e);return new z(t,e,n,r)},tp$call(t,e){return this.wrapper(t,e)},tp$descr_get(t,e){return null===t?this:new M(this,t)},tp$doc:"Create a cached callable that wraps another function.\n\nuser_function:      the function being cached\n\nmaxsize:  0         for no caching\n          None      for unlimited cache size\n          n         for a bounded cache\n\ntyped:    False     cache f(3) and f(3.0) as identical calls\n          True      cache f(3) and f(3.0) as distinct calls\n\ncache_info_type:    namedtuple class with the fields:\n                        hits misses currsize maxsize\n"},methods:{cache_info:{$meth(){return m(st,[this.hits,this.misses,-1===this.maxsize?_:this.maxsize,this.cache.get$size()].map(t=>x(t)))},$flags:{NoArgs:!0},$doc:"Report cache statistics"},cache_clear:{$meth(){return this.hits=this.misses=0,this.root={},this.root.next=this.root.prev=this.root,m(this.cache.tp$getattr(new o("clear"),!0))},$flags:{NoArgs:!0},$doc:"Clear the cache and cache statistics"},__deepcopy__:{$meth(t){return this},$flags:{OneArg:!0}},__copy__:{$meth(){return this},$flags:{NoArgs:!0}}},getsets:{__dict__:j}});function at(t,e){const n=pt(t,e,this.typed);var r=this.cache.mp$lookup(n);return void 0!==r?(this.hits++,r):(this.misses++,$(m(this.func,t,e),t=>(this.cache.mp$ass_subscript(n,t),t)))}function it(t,e){return this.misses++,m(this.func,t,e)}function ot(t,e){const a=pt(t,e,this.typed);var n,r=this.cache.mp$lookup(a);return void 0!==r?(n=r["result"],ct(r),T(this,r),this.hits++,n):(this.misses++,$(m(this.func,t,e),t=>{var e,n,r=this.cache.mp$lookup(a);if(void 0===r)if(this.cache.get$size()<this.maxsize||this.root.next===this.root){const s={key:a,result:t};this.cache.mp$ass_subscript(a,s),T(this,s)}else{const s=this.root.next;if(ct(s),void 0===this.cache.pop$item(s.key))throw r=this,e=s,r=r.root,((n=r.next).prev=r.next=e).prev=r,e.next=n,new O("cached item removed unexpectedly");s.key=a,s.result=t,this.cache.mp$ass_subscript(a,s),T(this,s)}return t}))}function ct(t){var{prev:e,next:n}=t;e.next=t.next,n.prev=t.prev}function T(t,e){var t=t.root,n=t.prev;(n.next=t.prev=e).prev=n,e.next=t}const _t=n("_HachedSeq",{base:e,constructor:function(t){this.$hashval=Q(new i(t)),e.call(this,t)},slots:{tp$hash(){return this.$hashval}}}),ht=new a,ut=new Set([t,o]);function pt(t,e,n){var r=t.slice(0),s=[];if(e&&e.length){r.push(ht);for(let t=0;t<e.length;t+=2){var a=e[t+1];s.push(a),r.push(new i([new o(e[t]),a]))}}if(k(n))r.push(...t.map(t=>t.ob$type),...s.map(t=>t.ob$type));else if(1===r.length&&ut.has(r[0].ob$type))return r[0];return new _t(r)}function lt(t,e){return{args:t=this.arg_arr.concat(t),kwargs:e=e?(e=S(e),(t=this.kwdict.dict$copy()).dict$merge(e),A(t)):A(this.kwdict)}}function dt(t,e){if(t.length<1)throw new p("type 'partial' takes at least 1 argument");let n=t.shift(),r,s;var a;n instanceof this.sk$builtinBase&&(n=(a=n).fn,r=a.arg_arr,s=a.kwdict),this.check$func(n),r&&(t=r.concat(t)),e=e||[];let i=S(e);return s&&((a=s.dict$copy()).dict$merge(i),i=a),this.sk$builtinBase===this.constructor?new this.constructor(n,t,i):(e=new this.constructor,this.sk$builtinBase.call(e,n,t,i),e)}function ft(){if(this.in$repr)return new o("...");this.in$repr=!0;const n=[v(this.fn)];return this.arg_arr.forEach(t=>{n.push(v(t))}),this.kwdict.$items().forEach(([t,e])=>{n.push(t.toString()+"="+v(e))}),this.in$repr=!1,new o(this.tp$name+"("+n.join(", ")+")")}s.partial=n("functools.partial",{constructor:function(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new i(e),this.kwdict=n,this.in$repr=!1,this.$d=new c([])},slots:{tp$new:dt,tp$call(t,e){return{args:t,kwargs:e}=this.adj$args_kws(t,e),this.fn.tp$call(t,e)},tp$doc:"partial(func, *args, **keywords) - new function with partial application\n    of the given arguments and keywords.\n",$r:ft,tp$getattr:Z,tp$setattr:tt},getsets:{func:{$get(){return this.fn},$doc:"function object to use in future partial calls"},args:{$get(){return this.arg_tup},$doc:"tuple of arguments to future partial calls"},keywords:{$get(){return this.kwdict},$doc:"dictionary of keyword arguments to future partial calls"},__dict__:j},methods:{},classmethods:Sk.generic.classGetItem,proto:{adj$args_kws:lt,check$func(t){if(!g(t))throw new p("the first argument must be callable")}}}),s.partialmethod=n("functools.partialmethod",{constructor:function(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new i(e),this.kwdict=n},slots:{tp$new:dt,tp$doc:"Method descriptor with partial application of the given arguments\n    and keywords.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    ",$r:ft,tp$descr_get(t,e){let n;if(this.fn.tp$descr_get){var r=this.fn.tp$descr_get(t,e);if(r!==this.fn){if(!g(r))throw new p("type 'partial' requires a callable");n=new s.partial(r,this.arg_arr.slice(0),this.kwdict.dict$copy());r=X(r,this.str$self);void 0!==r&&n.tp$setattr(this.str$self,r)}}return n=void 0===n?this.make$unbound().tp$descr_get(t,e):n}},methods:{_make_unbound_method:{$meth(){return this.make$unbound()},$flags:{NoArgs:!0}}},classmethods:Sk.generic.classGetItem,getsets:{func:{$get(){return this.fn},$doc:"function object to use in future partial calls"},args:{$get(){return this.arg_tup},$doc:"tuple of arguments to future partial calls"},keywords:{$get(){return this.kwdict},$doc:"dictionary of keyword arguments to future partial calls"},__dict__:j},proto:{str$self:new o("__self__"),make$unbound(){const r=this;function t(t,e){var n=t.shift();return{args:t,kwargs:e}=r.adj$args_kws(t,e),t.unshift(n),m(r.fn,t,e)}return t.co_fastcall=!0,new u(t)},adj$args_kws:lt,check$func(t){if(!g(t)&&void 0===t.tp$descr_get)throw new p(v(t)+" is not callable or a descriptor")}}});const gt={__lt__:o.$lt,__le__:o.$le,__gt__:o.$gt,__ge__:o.$ge};function q(t,r){const s=gt[t];function e(t,e){var n=w(t.tp$getattr(s),[e]);return n===C?n:(n=k(n),new D(r(n,t,e)))}return e.co_name=s,e}var tt=q("__lt__",(t,e,n)=>!t&&r(e,n,"NotEq")),j=q("__lt__",(t,e,n)=>t||r(e,n,"Eq")),wt=q("__lt__",t=>!t),mt=q("__le__",(t,e,n)=>!t||r(e,n,"Eq")),$t=q("__le__",(t,e,n)=>t&&r(e,n,"NotEq")),yt=q("__le__",t=>!t),bt=q("__gt__",(t,e,n)=>!t&&r(e,n,"NotEq")),kt=q("__gt__",(t,e,n)=>t||r(e,n,"Eq")),vt=q("__gt__",t=>!t),xt=q("__ge__",(t,e,n)=>!t||r(e,n,"Eq")),At=q("__ge__",(t,e,n)=>t&&r(e,n,"NotEq")),St=q("__ge__",t=>!t);const Et={__lt__:{__gt__:new u(tt),__le__:new u(j),__ge__:new u(wt)},__le__:{__ge__:new u(mt),__lt__:new u($t),__gt__:new u(yt)},__gt__:{__lt__:new u(bt),__ge__:new u(kt),__le__:new u(vt)},__ge__:{__le__:new u(xt),__gt__:new u(At),__lt__:new u(St)}},Nt={__lt__:"ob$lt",__le__:"ob$le",__gt__:"ob$gt",__ge__:"ob$ge"};const Pt=new o("get"),Rt=new a,jt=(s.cached_property=n("functools.cached_property",{constructor:function(){},slots:{tp$init(t,e){V("cached_property",t,e),H("cached_property",e),this._func=t[0],this._attr=_},tp$descr_get(n,t,e){if(null==n)return this;if(this._attr===_)throw new p("Cannot use cached_property instance without calling __set_name__ on it.");let r;try{r=R(n,o.$dict)}catch(t){if(t instanceof l)throw s=`No '__dict__' attribute on '${N(n)}' `+`instance to cache ${v(this._attr)} property.`,new p(s);throw t}var s=R(r,Pt);let a=w(s,[this._attr,Rt]);if(a===Rt){const i=m(this._func,[n]);a=L(i,e=>{try{return Y(r,this._attr,i),e}catch(t){if(t instanceof p)throw e=`The '__dict__' attribute on '${N(n)}' instance `+`does not support item assignment for caching ${v(this._attr)} property.`,new p(e);throw t}})}return e?a:K(a)}},getsets:{__doc__:{$get(){return this._func.tp$getattr(o.$doc)||_}}},methods:{__set_name__:{$meth(t,e){if(this._attr===_)this._attr=e;else if(e.toString()!==this._attr.toString())throw new p(`Cannot assign the same cached_property to two different names (${v(this._attr)} and ${v(e)})`)},$flags:{MinArgs:2,MaxArgs:2}}},classmethods:Sk.generic.classGetItem}),new t(0)),I=n("functools.KeyWrapper",{constructor:function(t,e){this.cmp=t,this.obj=e},slots:{tp$call(t,e){var[t]=E("K",["obj"],t,e,[]);return new I(this.cmp,t)},tp$richcompare(t,e){if(!(t instanceof I))throw new p("other argument must be K instance");var n=this.obj,t=t.obj;if(n&&t)return n=m(this.cmp,[n,t]),$(n,t=>r(t,jt,e));throw new l("object")},tp$getattr:Z,tp$hash:_},getsets:{obj:{$get(){return this.obj||_},$set(t){this.obj=t},$doc:"Value wrapped by a key function."}}}),zt=new o("update"),Tt=new o("__wrapped__");return J("functools",s,{cache:{$meth:function(t){return m(rt(_),[t])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called "memoize".',$textsig:"($module, user_function, /)"},lru_cache:{$meth:rt,$flags:{NamedArgs:["maxsize","typed"],Defaults:[new t(128),h]},$doc:`Least-recently-used cache decorator.

If *maxsize* is set to None, the LRU features are disabled and the cache
can grow without bound.

If *typed* is True, arguments of different types will be cached separately.
For example, f(3.0) and f(3) will be treated as distinct calls with
distinct results.

Arguments to the cached function must be hashable.

View the cache statistics named tuple (hits, misses, maxsize, currsize)
with f.cache_info().  Clear the cache and statistics with f.cache_clear().
Access the underlying function with f.__wrapped__.

See:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)`},cmp_to_key:{$meth:function(t){return new I(t)},$flags:{NamedArgs:["mycmp"],Defaults:[]},$doc:"Convert a cmp= function into a key= function.",$textsig:"($module, cmp, /)"},reduce:{$meth:function(e,t,n){const r=P(t);let s;return n=n||r.tp$iternext(!0),$(n,t=>{if(void 0===t)throw new p("reduce() of empty sequence with no initial value");return s=t,F(r,t=>$(m(e,[s,t]),t=>{s=t}))},()=>s)},$flags:{MinArgs:2,MaxArgs:3},$doc:"reduce(function, sequence[, initial]) -> value\n\nApply a function of two arguments cumulatively to the items of a sequence,\nfrom left to right, so as to reduce the sequence to a single value.\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\nof the sequence in the calculation, and serves as a default when the\nsequence is empty.",$textsig:"($module, function, sequence[, initial], /)"},total_ordering:{$meth:function(n){const r=[];if(!B(n))throw new p("total ordering only supported for type objects not '"+N(n)+"'");var t;if(Object.keys(Et).forEach(t=>{var e=Nt[t];n.prototype[e]!==a.prototype[e]&&r.push(t)}),r.length)return t=r[0],Object.entries(Et[t]).forEach(([t,e])=>{r.includes(t)||n.tp$setattr(gt[t],e)}),n;throw new W("must define atleast one ordering operation: <, >, <=, >=")},$flags:{OneArg:!0},$doc:"Class decorator that fills in missing ordering methods"},update_wrapper:{$meth:function(e,n,t,r){let s=P(t),a;for(let t=s.tp$iternext();void 0!==t;t=s.tp$iternext())void 0!==(a=n.tp$getattr(t))&&e.tp$setattr(t,a);for(let t=(s=P(r)).tp$iternext();void 0!==t;t=s.tp$iternext()){a=n.tp$getattr(t)||new c([]);var i=R(e,t),i=R(i,zt);w(i,[a])}return e.tp$setattr(Tt,n),e},$flags:{NamedArgs:["wrapper","wrapped","assigned","updated"],Defaults:[s.WRAPPER_ASSIGNMENTS,s.WRAPPER_UPDATES]},$doc:"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    ",$textsig:"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))"},wraps:{$meth:function(t,e,n){t=["wrapped",t,"assigned",e,"updated",n];return m(s.partial,[s.update_wrapper],t)},$flags:{NamedArgs:["wrapped","assigned","updated"],Defaults:[s.WRAPPER_ASSIGNMENTS,s.WRAPPER_UPDATES]},$doc:"Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    ",$textsig:"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))"}}),s}