function $builtinmodule(){const{isTrue:P,richCompareBool:W,asIndexOrThrow:Z,asIndexSized:K,objectRepr:V,opAllowsEquality:It,callsimArray:Q}=Sk.misceval,{numberBinOp:t,typeName:tt,buildNativeClass:et,checkArgsLen:nt,objectHash:it,copyKeywordsToNamedArgs:st}=Sk.abstr,{int_:rt,float_:ot,str:$t,bytes:at,tuple:ht,bool:{true$:ut},none:{none$:ct},NotImplemented:{NotImplemented$:lt},TypeError:mt,ValueError:ft,OverflowError:dt,ZeroDivisionError:wt,NotImplementedError:Et,checkNumber:kt,checkFloat:gt,checkString:pt,checkInt:Tt,asnum$:yt,round:e,getattr:Rt}=Sk.builtin,{remapToPy:qt,remapToJs:Ct}=Sk.ffi,Dt=t=>e(t).nb$int(),bt=t,Ut=new $t("auto"),vt=new $t("utcoffset"),_t=new $t("tzname"),n=new $t("as_integer_ratio"),zt=new $t("dst"),Yt=new $t("isoformat"),At=new $t("replace"),jt=new $t("fromtimestamp"),Ft=new $t("fromordinal"),Ht=new $t("utcfromtimestamp"),Jt=new $t("strftime"),Bt=new $t("fromutc"),xt=new rt(0),Gt=new ot(0),Lt=new rt(7),Xt=new rt(60),Pt=new rt(3600),Wt=new rt(1e3),Zt=new rt(1e6),Kt=new ot(1e6),Vt=new rt(86400),Qt=new ot(86400);let te=null;function Nt(t,e){return bt(t,e,"DivMod").v}function St(t,e){if("number"!=typeof t||"number"!=typeof e)return t=JSBI.BigInt(t),e=JSBI.BigInt(e),[JSBI.toNumber(JSBI.divide(t,e)),JSBI.toNumber(JSBI.remainder(t,e))];if(0===e)throw new wt("integer division or modulo by zero");return[Math.floor(t/e),t-Math.floor(t/e)*e]}function ee(t){var e=(t=yt(t))<0?-1:1;return t=Math.abs(t),[new ot(e*(t-Math.floor(t))),new ot(e*Math.floor(t))]}function Mt(t,e="0",n=2){return t.toString().padStart(n,e)}const i=/^[0-9]+$/;function Ot(t){if(i.test(t))return parseInt(t);throw new Error}function ne(t){t=Q(t.tp$getattr(n));if(!(t instanceof ht))throw new mt("unexpected return type from as_integer_ratio(): expected tuple, got '"+tt(t)+"'");if(2!==(t=t.v).length)throw new ft("as_integer_ratio() must return a 2-tuple");return t}return Sk.misceval.chain(Sk.importModule("time",!1,!0),t=>{const m=t.$d;t={__name__:new $t("datetime"),__all__:new Sk.builtin.list(["date","datetime","time","timedelta","timezone","tzinfo","MINYEAR","MAXYEAR"].map(t=>new $t(t)))};function $(e,n){for(let t=0;t<e.length;t++)if(e[t]!==n[t])return e[t]>n[t]?1:-1;return 0}function n(t,e,n){var i=t.$cmp(e,n);switch(n){case"Lt":return i<0;case"LtE":return i<=0;case"Eq":return 0===i;case"NotEq":return 0!==i;case"Gt":return 0<i;case"GtE":return 0<=i}}const o=1,a=9999,h=(t.MINYEAR=new rt(o),t.MAXYEAR=new rt(a),[-1,31,28,31,30,31,30,31,31,30,31,30,31]),u=[-1];let e=0;function c(t){return t%4==0&&(t%100!=0||t%400==0)}function i(t){t-=1;return 365*t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400)}function l(t,e){return u[e]+(2<e&&c(t))}function f(t,e,n){return i(t)+l(t,e)+n}h.slice(1).forEach(t=>{u.push(e),e+=t});const C=i(401),D=i(101),U=i(5);function r(t){if((t=Z(t))>Number.MAX_SAFE_INTEGER)throw new dt("Python int too large to convert to js number");if(t<1)throw new ft("ordinal must be >= 1");--t,[i,t]=St(t,C);var e,n,i=400*i+1;if([e,t]=St(t,D),[n,t]=St(t,U),[s,t]=St(t,365),i+=100*e+4*n+s,4===s||4===e)return[i-1,12,31].map(t=>new rt(t));var s=3===s&&(24!==n||3===e);let r=t+50>>5,o=u[r]+(2<r&&s);return o>t&&(--r,o-=h[r]+(2===r&&s)),t-=o,[i,r,t+1].map(t=>new rt(t))}const s=[null,"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],d=[null,"Mon","Tue","Wed","Thu","Fri","Sat","Sun"];function w(t,e,n,i,s,r,o){var $=(f(t,e,n)+6)%7,a=l(t,e)+n;return m.struct_time.tp$call([new ht([t,e,n,i,s,r,$,a,o].map(t=>new rt(t)))])}const Y={hours(t){return Mt(t)},minutes(t,e){return Mt(t)+":"+Mt(e)},seconds(t,e,n){return Mt(t)+":"+Mt(e)+":"+Mt(n)},milliseconds(t,e,n,i){return Mt(t)+":"+Mt(e)+":"+Mt(n)+"."+Mt(i,"0",3)},microseconds(t,e,n,i){return Mt(t)+":"+Mt(e)+":"+Mt(n)+"."+Mt(i,"0",6)}};function g(t,e,n,i,s="auto"){if("string"!=typeof s&&!pt(s))throw new mt("must be str, not "+tt(s));"auto"===(s=s.toString())?s=i?"microseconds":"seconds":"milliseconds"===s&&(i=Math.floor(i/1e3));s=Y[s];if(void 0===s)throw new ft("Unknown timespec value");return s(t,e,n,i)}function p(t){let e="",n;var i,s;if(t!==ct)return t.$days<0?(n="-",t=new N(-t.$days,-t.$secs,-t.$micro)):n="+",[t,i]=Nt(t,S),[i,s]=Nt(i,M),e+=n+(Mt(t)+":"+Mt(i)),(s.$secs||s.$micro)&&(e+=":"+Mt(s.$secs,"0",2),s.$micro)&&(e+="."+Mt(s.$micro,"0",6)),e}function y(e,n,t){let i=null,s=null,r=null,o=[],$=0;for(var a=n.length;$<a;){let t=n[$];if($+=1,"%"===t)if($<a)if(t=n[$],$+=1,"f"===t)null===i&&(i=Mt(e.$micro||0,"0",6)),o.push(i);else if("z"===t){if(null===s){s="";var h=e.tp$getattr(vt);if(void 0!==h){let e=Q(h);if(e!==ct){let t="+";e.$days<0&&(e=new N(-e.$days,-e.$secs,-e.$micro),t="-"),[h,c]=Nt(e,S),[u,c]=Nt(c,M);var u,c=c.$secs,l=e.$micro;s=l?t+Mt(h)+Mt(u)+Mt(c)+"."+Mt(l,"0",6):c?t+Mt(h)+Mt(u)+Mt(c):t+Mt(h)+Mt(u)}}}o.push(s)}else if("Z"===t){if(null===r){r="";l=e.tp$getattr(_t);if(void 0!==l){c=Q(l);if(c!==ct){h=c.tp$getattr(At);if(r=Q(h,[new $t("%"),new $t("%%")]),!pt(r))throw new mt("tzname.replace() did not return a string")}}}o.push(r)}else o.push("%",t);else o.push("%");else o.push(t)}return o=o.join(""),m.strftime.tp$call([new $t(o),t])}function b(t){var e=Ot(t.slice(0,4));if("-"!==t[4])throw new ft("Invalid date separator: "+t[4]);var n=Ot(t.slice(5,7));if("-"!==t[7])throw new ft("Invalid date separator: "+t[7]);return[e,n,Ot(t.slice(8,10))].map(t=>new rt(t))}function v(e){var n=e.length,i=[0,0,0,0];let s=0;for(let t=0;t<3;t++){if(n-s<2)throw new ft("Incomplete time component");i[t]=Ot(e.slice(s,s+2)),s+=2;var r=e.substr(s,1);if(!r||2<=t)break;if(":"!==r)throw new ft("Invalid time separator: "+r);s+=1}if(s<n){if("."!==e[s])throw new ft("Invalid microsecond component");var t=n-(s+=1);if(3!=t&&6!=t)throw new ft("Invalid microsecond component");i[3]=Ot(e.slice(s)),3==t&&(i[3]*=1e3)}return i}function _(t){if(t.length<2)throw new ft("Isoformat time too short");var e=t.indexOf("-")+1||t.indexOf("+")+1;let n=v(0<e?t.slice(0,e-1):t),i=ct;if(0<e){if(s=t.slice(e),![5,8,15].includes(s.length))throw new ft("Malformed time zone string");var s=v(s);i=s.every(t=>0===t)?q.prototype.utc:(t="-"===t[e-1]?-1:1,e=new N(0,t*(3600*s[0]+60*s[1]+s[2]),t*s[3]),new q(e))}return(n=n.map(t=>new rt(t))).push(i),n}function j(t){if(t!==ct&&!pt(t))throw new mt("tzinfo.tzname() must return None or string, not '"+tt(t)+"'")}function z(t,e){if(e!==ct){if(!(e instanceof N))throw new mt(`tzinfo.${t}() must return None or timedelta, not '${tt(e)}'`);if(!W(G,e,"Lt")||!W(e,J,"Lt"))throw new ft(`${t}()=${e.toString()}, must be strictly between -timedelta(hours=24) and timedelta(hours=24)`)}}function F(t,e=null,n=null){if(null===e||null===n)throw i=null===n?"day":"month",s=null===n?"3":"2",new mt(`function missing required argument '${i}' (pos ${s})`);if(t=Z(t),e=Z(e),n=Z(n),!(o<=t&&t<=a))throw new ft("year must be in "+o+".."+a,new rt(t));if(!(1<=e&&e<=12))throw new ft("month must be in 1..12",new rt(e));i=t;var i,s,r=2===(s=e)&&c(i)?29:h[s];if(1<=n&&n<=r)return[t,e,n];throw new ft("day must be in 1.."+r,new rt(n))}function H(t,e,n,i,s){if(t=Z(t),e=Z(e),n=Z(n),i=Z(i),s=Z(s),!(0<=t&&t<=23))throw new ft("hour must be in 0..23",new rt(t));if(!(0<=e&&e<=59))throw new ft("minute must be in 0..59",new rt(e));if(!(0<=n&&n<=59))throw new ft("second must be in 0..59",new rt(n));if(!(0<=i&&i<=999999))throw new ft("microsecond must be in 0..999999",new rt(i));if(0!==s&&1!==s)throw new ft("fold must be either 0 or 1",new rt(s));return[t,e,n,i,s]}function A(t){if(t!==ct&&!(t instanceof E))throw new mt("tzinfo argument must be None or of a tzinfo subclass")}function x(t,e){let[n,i]=St(t,e);return i*=2,((0<e?e<i:i<e)||i===e&&Math.abs(n)%2==1)&&(n+=1),n}const N=t.timedelta=et("datetime.timedelta",{constructor:function(t=0,e=0,n=0){var i;if([i,n]=St(n,1e6),e+=i,[i,e]=St(e,86400),this.$days=t+=i,this.$secs=e,this.$micro=n,this.$hashcode=-1,999999999<Math.abs(t))throw new dt(`days=${t}; must have magnitude <= 999999999`)},slots:{tp$new(t,e){let[n,i,s,r,o,$,a]=st("timedelta",["days","seconds","microseconds","milliseconds","minutes","hours","weeks"],t,e,new Array(7).fill(xt)),h,u,c;h=u=c=xt,n=bt(n,bt(a,Lt,"Mult"),"Add"),i=bt(i,bt(bt(o,Xt,"Mult"),bt($,Pt,"Mult"),"Add"),"Add"),s=bt(s,bt(r,Wt,"Mult"),"Add");let l,m,f;h=gt(n)?([l,n]=ee(n),[m,f]=ee(bt(l,Qt,"Mult")),u=new rt(f),new rt(n)):(m=Gt,n);let d;d=gt(i)?([d,i]=ee(i),i=new rt(i),bt(d,m,"Add")):m,[n,i]=Nt(i,Vt),h=bt(h,n,"Add"),u=bt(u,new rt(i),"Add");t=bt(d,Kt,"Mult");if(gt(s)?(s=Dt(bt(s,t,"Add")),[i,s]=Nt(s,Zt),[n,i]=Nt(i,Vt),h=bt(h,n,"Add"),u=bt(u,i,"Add")):(s=new rt(s),[i,s]=Nt(s,Zt),[n,i]=Nt(i,Vt),h=bt(h,n,"Add"),u=bt(u,i,"Add"),s=Dt(bt(s,t,"Add"))),[i,c]=Nt(s,Zt),u=bt(u,i,"Add"),[n,u]=Nt(u,Vt),h=bt(h,n,"Add"),h=Z(h),u=Z(u),c=Z(c),999999999<Math.abs(h))throw new dt("timedelta # of days is too large: "+n.toString());return this===N.prototype?new N(h,u,c):(e=new this.constructor,N.call(e,h,u,c),e)},$r(){var t=[];return this.$days&&t.push("days="+this.$days),this.$secs&&t.push("seconds="+this.$secs),this.$micro&&t.push("microseconds="+this.$micro),t.length||t.push("0"),new $t(`${this.tp$name}(${t.join(", ")})`)},tp$str(){var t=this.$secs%60,e=Math.floor(this.$secs/60);let n=`${Math.floor(e/60)}:${Mt(e%=60)}:`+Mt(t);return this.$days&&(n=`${this.$days} day${e=this.$days,1!==Math.abs(e)?"s":""}, `+n),this.$micro&&(n+="."+Mt(this.$micro,"0",6)),new $t(n)},tp$as_number:!0,nb$add(t){return t instanceof N?new N(this.$days+t.$days,this.$secs+t.$secs,this.$micro+t.$micro):lt},nb$subtract(t){return t instanceof N?new N(this.$days-t.$days,this.$secs-t.$secs,this.$micro-t.$micro):lt},nb$positive(){return this},nb$negative(){return new N(-this.$days,-this.$secs,-this.$micro)},nb$abs(){return this.$days<0?this.nb$negative():this},nb$multiply(t){var e,n;return Tt(t)?(t=K(t,dt),new N(this.$days*t,this.$secs*t,this.$micro*t)):gt(t)?(e=this.$toMicrosecs(),[t,n]=ne(t),t=K(t,dt),n=Z(n),new N(0,0,x(e*t,n))):lt},nb$floor_divide(t){var e=this.$toMicrosecs();if(t instanceof N){var n=t.$toMicrosecs();if(0===n)throw new wt("integer division or modulo by zero");return new rt(Math.floor(e/n))}if(Tt(t)){if(0===(t=K(t,dt)))throw new wt("integer division or modulo by zero");return new N(0,0,Math.floor(e/t))}return lt},nb$divide(t){var e,n=this.$toMicrosecs();if(t instanceof N){if(0===t.$toMicrosecs())throw new wt("integer division or modulo by zero");return new ot(n/t.$toMicrosecs())}return Tt(t)?(t=Z(t),new N(0,0,x(n,t))):gt(t)?([t,e]=ne(t),t=Z(t),e=K(e,dt),new N(0,0,x(e*n,t))):lt},nb$remainder(t){if(!(t instanceof N))return lt;var e=this.$toMicrosecs(),t=t.$toMicrosecs();if(0===t)throw new wt("integer division or modulo by zero");e-=Math.floor(e/t)*t;return new N(0,0,e)},nb$divmod(t){var e;return t instanceof N?([t,e]=St(this.$toMicrosecs(),t.$toMicrosecs()),new ht([new rt(t),new N(0,0,e)])):lt},tp$richcompare(t,e){return t instanceof N?n(this,t,e):lt},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=it(new ht(this.$getState().map(t=>new rt(t))))),this.$hashcode},nb$bool(){return 0!==this.$days||0!==this.$secs||0!==this.$micro}},methods:{total_seconds:{$meth(){return new ot((1e6*(86400*this.$days+this.$secs)+this.$micro)/1e6)},$flags:{NoArgs:!0},$doc:"Total seconds in the duration."},__reduce__:{$meth(){return new ht([this.ob$type,new ht(this.$getState().map(t=>qt(t)))])},$flags:{NoArgs:!0},$textsig:null,$doc:"__reduce__() -> (cls, state)"}},getsets:{days:{$get(){return new rt(this.$days)},$doc:"Number of days."},seconds:{$get(){return new rt(this.$secs)},$doc:"Number of seconds (>= 0 and less than 1 day)."},microseconds:{$get(){return new rt(this.$micro)},$doc:"Number of microseconds (>= 0 and less than 1 second)."}},proto:{$toMicrosecs(){return 1e6*(86400*this.$days+this.$secs)+this.$micro},$cmp(t){return $(this.$getState(),t.$getState())},$getState(){return[this.$days,this.$secs,this.$micro]}}}),J=(N.prototype.min=new N(-999999999),N.prototype.max=new N(999999999,86399,999999),N.prototype.resolution=new N(0,0,1),new N(1)),S=new N(0,3600),M=new N(0,60),O=new N(0,1),B=new N(0),G=new N(-1),I=t.date=et("datetime.date",{constructor:function(t,e,n){this.$year=t,this.$month=e,this.$day=n,this.$hashcode=-1},slots:{tp$new(t,e){let[n,i,s]=st("date",["year","month","day"],t,e,[null,null]),r;return null===i&&n instanceof at&&4===(r=n.valueOf()).length&&1<=r[2]&&r[2]<=12?((t=new this.constructor).$setState(r),t):([n,i,s]=F(n,i,s),this===I.prototype?new I(n,i,s):(e=new this.constructor,I.call(e,n,i,s),e))},$r(){return new $t(`${this.tp$name}(${this.$year}, ${this.$month}, ${this.$day})`)},tp$str(){return this.tp$getattr(Yt).tp$call([])},tp$richcompare(t,e){return t instanceof I?n(this,t,e):lt},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=it(this.$getState())),this.$hashcode},tp$as_number:!0,nb$add(t){if(t instanceof N){t=this.$toOrdinal()+t.$days;if(0<t&&t<=3652059)return this.ob$type.tp$getattr(Ft).tp$call([new rt(t)]);throw new dt("result out of range")}return lt},nb$subtract(t){var e;return t instanceof N?bt(this,new N(-t.$days),"Add"):t instanceof I?(e=this.$toOrdinal(),t=t.$toOrdinal(),new N(e-t)):lt},nb$reflected_subtract:null},classmethods:{fromtimestamp:{$meth:function(t){var[t,e,n]=m.localtime.tp$call([t]).v;return this.tp$call([t,e,n])},$flags:{OneArg:!0},$textsig:null,$doc:"timestamp -> local date from a POSIX timestamp (like time.time())."},fromordinal:{$meth:function(t){return this.tp$call(r(t))},$flags:{OneArg:!0},$textsig:null,$doc:"int -> date corresponding to a proleptic Gregorian ordinal."},fromisocalendar:{$meth:function(t,e,n){if(t=Z(t),e=Z(e),n=Z(n),!(o<=t&&t<=a))throw new ft("Year is out of range: "+t);let i,s;if(!(0<e&&e<53)&&(i=!0,i=(53!==e||!(4==(s=f(t,1,1)%7)||3==s&&c(t)))&&i))throw new ft("Invalid week: "+e);if(0<n&&n<8)return e=7*(e-1)+(n-1),t=R(t),this.tp$call(r(t+e));throw new ft(`Invalid weekday: ${n} (range is [1, 7])`)},$flags:{NamedArgs:["year","week","day"]},$textsig:null,$doc:"int -> date corresponding to a proleptic Gregorian ordinal."},fromisoformat:{$meth:function(e){if(!pt(e))throw new mt("fromisoformat: argument must be str");e=e.toString();try{if(10!==e.length)throw new Error;return this.tp$call(b(e))}catch(t){throw new ft("Invalid isoformat string: '"+e+"'")}},$flags:{OneArg:!0},$textsig:null,$doc:"str -> Construct a date from the output of date.isoformat()"},today:{$meth:function(){var t=m.time.tp$call([]);return this.tp$getattr(jt).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:"Current date or datetime:  same as self.__class__.fromtimestamp(time.time())."}},methods:{ctime:{$meth:function(){var t=this.$toOrdinal()%7||7,t=d[t],e=s[this.$month];return new $t(`${t} ${e} ${Mt(this.$day," ",2)} 00:00:00 `+Mt(this.$year,"0",4))},$flags:{NoArgs:!0},$textsig:null,$doc:"Return ctime() style string."},strftime:{$meth:function(t){if(pt(t))return y(this,t=t.toString(),this.$timetuple());throw new mt("must be str, not "+tt(t))},$flags:{OneArg:!0},$textsig:null,$doc:"format -> strftime() style string."},__format__:{$meth:function(t){if(pt(t))return t!==$t.$empty?this.tp$getattr(Jt).tp$call([t]):this.tp$str();throw new mt("must be str, not "+tt(t))},$flags:{OneArg:!0},$textsig:null,$doc:"Formats self with strftime."},timetuple:{$meth:function(){return this.$timetuple()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return time tuple, compatible with time.localtime()."},isocalendar:{$meth:function(){let t=this.$year;var e=R(t),n=f(this.$year,this.$month,this.$day);let[i,s]=St(n-e,7);return i<0?(e=R(--t),[i,s]=St(n-e,7)):52<=i&&n>=R(t+1)&&(t+=1,i=0),new L(new rt(t),new rt(i+1),new rt(s+1))},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a 3-tuple containing ISO year, week number, and weekday."},isoformat:{$meth:function(){return this.$isoformat()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return string in ISO 8601 format, YYYY-MM-DD."},isoweekday:{$meth:function(){return new rt(this.$toOrdinal()%7||7)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return the day of the week represented by the date.\nMonday == 1 ... Sunday == 7"},toordinal:{$meth:function(){return new rt(this.$toOrdinal())},$flags:{NoArgs:!0},$textsig:null,$doc:"Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1."},weekday:{$meth:function(){return new rt((this.$toOrdinal()+6)%7)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return the day of the week represented by the date.\nMonday == 0 ... Sunday == 6"},replace:{$meth:function(t,e,n){return t===ct&&(t=new rt(this.$year)),e===ct&&(e=new rt(this.$month)),n===ct&&(n=new rt(this.$day)),this.ob$type.tp$call([t,e,n])},$flags:{NamedArgs:["year","month","day"],Defaults:[ct,ct,ct]},$textsig:null,$doc:"Return date with new specified fields."},__reduce__:{$meth(){return new ht([this.ob$type,new ht([this.$getState()])])},$flags:{NoArgs:!0},$textsig:null,$doc:"__reduce__() -> (cls, state)"}},getsets:{year:{$get(){return new rt(this.$year)},$doc:"year (1-9999)"},month:{$get(){return new rt(this.$month)},$doc:"month (1-12)"},day:{$get(){return new rt(this.$day)},$doc:"day (1-31)"}},proto:{$cmp(t){return $([this.$year,this.$month,this.$day],[t.$year,t.$month,t.$day])},$getState(){var[t,e]=St(this.$year,256);return new at([t,e,this.$month,this.$day])},$setState(t){var[t,e,n,i]=t;this.$year=256*t+e,this.$month=n,this.$day=i},$toOrdinal(){return f(this.$year,this.$month,this.$day)},$isoformat(){return new $t(`${Mt(this.$year,"0",4)}-${Mt(this.$month,"0",2)}-`+Mt(this.$day,"0",2))},$timetuple(){return w(this.$year,this.$month,this.$day,this.$hour||0,this.$min||0,this.$sec||0,-1)},$strftime(t=""){return y(this,t.toString(),this.$timetuple())}}}),E=(I.prototype.min=new I(1,1,1),I.prototype.max=new I(9999,12,31),I.prototype.resolution=new N(1),t.tzinfo=et("datetime.tzinfo",{constructor:function(){},methods:{tzname:{$meth:function(t){throw new Et("tzinfo subclass must override tzname()")},$flags:{OneArg:!0},$textsig:null,$doc:"datetime -> string name of time zone."},utcoffset:{$meth:function(t){throw new Et("tzinfo subclass must override utcoffset()")},$flags:{OneArg:!0},$textsig:null,$doc:"datetime -> timedelta showing offset from UTC, negative values indicating West of UTC"},dst:{$meth:function(t){throw new Et("tzinfo subclass must override dst()")},$flags:{OneArg:!0},$textsig:null,$doc:"datetime -> DST offset as timedelta positive east of UTC."},fromutc:{$meth:function(t){if(!(t instanceof T))throw new mt("fromutc() requires a datetime argument");if(t.$tzinfo!==this)throw new ft("dt.tzinfo is not self");var e=Q(t.tp$getattr(vt));if(e===ct)throw new ft("fromutc() requires a non-None utcoffset() result");let n=Q(t.tp$getattr(zt));if(n===ct)throw new ft("fromutc() requires a non-None dst() result");e=bt(e,n,"Sub");if(P(e)&&(t=bt(t,e,"Add"),(n=Q(t.tp$getattr(zt)))===ct))throw new ft("fromutc(): dt.dst gave inconsistent results; cannot convert");return bt(t,n,"Add")},$flags:{OneArg:!0},$textsig:null,$doc:"datetime in UTC -> datetime in local time."},__reduce__:{$meth(){let t,e;var n=Rt(this,new $t("__getinitargs__"),ct),n=(t=n!==ct?Q(n,[]):new ht,Rt(this,new $t("__getstate__"),ct));return(e=n!==ct?Q(n,[]):(e=Rt(this,new $t("__dict__"),ct),P(e)?e:ct))===ct?new ht([this.ob$type,t]):new ht([this.ob$type,t,e])},$flags:{NoArgs:!0},$textsig:null,$doc:"-> (cls, state)"}}})),L=et("datetime.IsoCalendarDate",{base:ht,constructor:function(t,e,n){this.y=t,this.w=e,this.wd=n,ht.call(this,[t,e,n])},slots:{tp$new(t,e){var[t,e,n]=st("IsoCalendarDate",["year","week","weekday"],t,e);return new this.constructor(t,e,n)},$r(){return new $t(`${this.tp$name}(year=${this.y}, week=${this.w}, weekday=${this.wd})`)}},getsets:{year:{$get(){return this.y}},week:{$get(){return this.w}},weekday:{$get(){return this.wd}}}}),k=t.time=et("datetime.time",{constructor:function(t=0,e=0,n=0,i=0,s=null,r=0){this.$hour=t,this.$min=e,this.$sec=n,this.$micro=i,this.$tzinfo=s||ct,this.$fold=r,this.$hashcode=-1},slots:{tp$new(t,e){nt("time",t,0,5);let[n,i,s,r,o,$]=st("time",["hour","minute","second","microsecond","tzinfo","fold"],t,e,[xt,xt,xt,xt,ct,xt]),a;return n instanceof at&&6===(a=n.valueOf()).length&&(127&a[0])<24?((t=new this.constructor).$setState(a,i===xt?ct:i),t):([n,i,s,r,$]=H(n,i,s,r,$),A(o),this===k.prototype?new k(n,i,s,r,o,$):(e=new this.constructor,k.call(e,n,i,s,r,o,$),e))},tp$richcompare(t,e){return t instanceof k?n(this,t,e):lt},tp$hash(){if(-1===this.$hashcode){var t=this.$fold?Q(this.tp$getattr(At),[],["fold",xt]):this,n=Q(t.tp$getattr(vt));if(P(n)){let[t,e]=Nt(new N(0,3600*this.$hour+60*this.$min).nb$subtract(n),S);e=e.nb$floor_divide(M),0<=t&&t<=24?(t=yt(t),e=yt(e),this.$hashcode=it(new k(t,e,this.$sec,this.$micro))):this.$hashcode=it(new ht([t,e,new rt(this.$sec),new rt(this.$micro)]))}else this.$hashcode=it(t.$getState()[0])}return this.$hashcode},$r(){let t;return t=0!==this.$micro?`, ${this.$sec}, `+this.$micro:0!==this.$sec?", "+this.$sec:"",t=`${this.tp$name}(${this.$hour}, ${this.$min}${t})`,this.$tzinfo!==ct&&(t=t.slice(0,-1)+", tzinfo="+V(this.$tzinfo)+")"),this.$fold&&(t=t.slice(0,-1)+", fold=1)"),new $t(t)},tp$str(){return this.tp$getattr(Yt).tp$call([])}},methods:{isoformat:{$meth:function(t){let e=g(this.$hour,this.$min,this.$sec,this.$micro,t);t=this.$tzstr();return t&&(e+=t),new $t(e)},$flags:{NamedArgs:["timespec"],Defaults:[Ut]},$textsig:null,$doc:"Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\n\ntimespec specifies what components of the time to include.\n"},strftime:{$meth:function(t){if(!pt(t))throw new mt("must be str, not "+tt(t));t=t.toString();var e=new ht([1900,1,1,this.$hour,this.$min,this.$sec,0,1,-1].map(t=>new rt(t)));return y(this,t,e)},$flags:{OneArg:!0},$textsig:null,$doc:"format -> strftime() style string."},__format__:{$meth:function(t){if(pt(t))return t!==$t.$empty?this.tp$getattr(Jt).tp$call([t]):this.tp$str();throw new mt("must be str, not "+tt(t))},$flags:{OneArg:!0},$textsig:null,$doc:"Formats self with strftime."},utcoffset:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(vt),z("utcoffset",t=Q(t,[ct])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.utcoffset(self)."},tzname:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(_t),j(t=Q(t,[ct])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.tzname(self)."},dst:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(zt),z("dst",t=Q(t,[ct])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.dst(self)."},replace:{$meth:function(t,e){nt("replace",t,0,5);let[n,i,s,r,o,$]=st("replace",["hour","minute","second","microsecond","tzinfo","fold"],t,e,[ct,ct,ct,ct,ut,ct]);return n===ct&&(n=new rt(this.$hour)),i===ct&&(i=new rt(this.$min)),s===ct&&(s=new rt(this.$sec)),r===ct&&(r=new rt(this.$micro)),o===ut&&(o=this.$tzinfo),$===ct&&($=new rt(this.$fold)),this.ob$type.tp$call([n,i,s,r,o],["fold",$])},$flags:{FastCall:!0},$textsig:null,$doc:"Return time with new specified fields."},__reduce_ex__:{$meth(t){return new ht([this.ob$type,new ht(this.$getState(Ct(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:"__reduce_ex__(proto) -> (cls, state)"},__reduce__:{$meth(){return this.tp$getattr(new $t("__reduce_ex__")).tp$call([new rt(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:"__reduce__() -> (cls, state)"}},classmethods:{fromisoformat:{$meth:function(t){if(!pt(t))throw new mt("fromisoformat: argument must be str");t=t.toString();try{return this.tp$call(_(t))}catch{throw new ft("Invalid isofrmat string: '"+t+"'")}},$flags:{OneArg:!0},$textsig:null,$doc:"string -> time from time.isoformat() output"}},getsets:{hour:{$get(){return new rt(this.$hour)}},minute:{$get(){return new rt(this.$min)}},second:{$get(){return new rt(this.$sec)}},microsecond:{$get(){return new rt(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new rt(this.$fold)}}},proto:{$cmp(t,e){var n=this.$tzinfo,i=t.$tzinfo;let s,r;s=r=ct;let o;if(o=n===i||(s=Q(this.tp$getattr(vt)),r=Q(t.tp$getattr(vt)),W(s,r,"Eq")))return $([this.$hour,this.$min,this.$sec,this.$micro],[t.$hour,t.$min,t.$sec,t.$micro]);if(s===ct||r===ct){if("Eq"===e||"NotEq"===e)return 2;throw new mt("cannot compare naive and aware times")}n=60*this.$hour+this.$min-K(s.nb$floor_divide(M)),i=60*t.$hour+t.$min-K(r.nb$floor_divide(M));return $([n,this.$sec,this.$micro],[i,t.$sec,t.$micro])},$tzstr(){return p(Q(this.tp$getattr(vt)))},$getState(t=3){var[e,n]=St(this.$micro,256),[e,i]=St(e,256);let s=this.$hour;this.$fold&&3<t&&(s+=128);t=new at([s,this.$min,this.$sec,e,i,n]);return this.$tzinfo===ct?[t]:[t,this.$tzinfo]},$setState(t,e){var[t,n,i,s,r,o]=t;127<t?(this.$fold=1,this.$hour=t-128):(this.$fold=0,this.$hour=t),this.$min=n,this.$sec=i,this.$micro=(s<<8|r)<<8|o,this.$tzinfo=e}}}),T=(k.prototype.min=new k(0,0,0),k.prototype.max=new k(23,59,59,999999),k.prototype.resolution=new N,t.datetime=et("datetime.datetime",{base:I,constructor:function(t,e,n,i=0,s=0,r=0,o=0,$=null,a=0){this.$year=t,this.$month=e,this.$day=n,this.$hour=i,this.$min=s,this.$sec=r,this.$micro=o,this.$tzinfo=$||ct,this.$fold=a,this.$hashcode=-1},slots:{tp$new(t,e){nt("datetime",t,0,9);let[n,i,s,r,o,$,a,h,u]=st("time",["year","month","day","hour","minute","second","microsecond","tzinfo","fold"],t,e,[null,null,xt,xt,xt,xt,ct,xt]),c;return n instanceof at&&10===(c=n.valueOf()).length&&(127&c[2])<=12?((t=new this.constructor).$setState(c,null===i?ct:i),t):([n,i,s]=F(n,i,s),[r,o,$,a,u]=H(r,o,$,a,u),A(h),this===T.prototype?new T(n,i,s,r,o,$,a,h,u):(e=new this.constructor,T.call(e,n,i,s,r,o,$,a,h,u),e))},$r(){var t=[this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro];0===t[t.length-1]&&t.pop(),0===t[t.length-1]&&t.pop();let e=`${this.tp$name}(${t.join(", ")})`;return this.$tzinfo!==ct&&(e=e.slice(0,-1)+", tzinfo="+V(this.$tzinfo)+")"),this.$fold&&(e=e.slice(0,-1)+", fold=1)"),new $t(e)},tp$str(){return this.tp$getattr(Yt).tp$call([],["sep",new $t(" ")])},tp$richcompare(t,e){if(t instanceof T)return n(this,t,e);if(!(t instanceof I))return lt;if("Eq"===e||"NotEq"===e)return"NotEq"===e;throw new mt(`can't compare '${tt(this)}' to '${tt(t)}'`)},tp$as_number:!0,nb$add(t){if(!(t instanceof N))return lt;var e=new N(this.$toOrdinal(),3600*this.$hour+60*this.$min+this.$sec,this.$micro),[t,n]=St((e=bt(e,t,"Add")).$secs,3600),[n,i]=St(n,60);if(0<e.$days&&e.$days<=3652059)return this.ob$type.tp$getattr(new $t("combine")).tp$call([I.tp$call(r(e.$days)),new k(t,n,i,e.$micro,this.$tzinfo)]);throw new dt("result out of range")},nb$subtract(t){if(!(t instanceof T))return t instanceof N?this.nb$add(t.nb$negative()):lt;var e=this.$toOrdinal(),n=t.$toOrdinal(),i=this.$sec+60*this.$min+3600*this.$hour,s=t.$sec+60*t.$min+3600*t.$hour,e=new N(e-n,i-s,this.$micro-t.$micro);if(this.$tzinfo===t.$tzinfo)return e;n=Q(this.tp$getattr(vt)),i=Q(t.tp$getattr(vt));if(W(n,i,"Eq"))return e;if(n===ct||i===ct)throw new mt("cannot mix naive and timezone-aware time");return e.nb$add(i).nb$subtract(n)},nb$reflected_subtract:null,tp$hash(){var t,e,n;return-1===this.$hashcode&&(e=this.$fold?Q(this.tp$getattr(At),[],["fold",xt]):this,(t=Q(e.tp$getattr(vt)))===ct?this.$hashcode=it(e.$getState()[0]):(e=f(this.$year,this.$month,this.$day),n=3600*this.$hour+60*this.$min+this.$sec,this.$hashcode=it(new N(e,n,this.$micro).nb$subtract(t)))),this.$hashcode}},methods:{date:{$meth:function(){return new I(this.$year,this.$month,this.$day)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return date object with same year, month and day."},time:{$meth:function(){return new k(this.$hour,this.$min,this.$sec,this.$micro,ct,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return time object with same time but with tzinfo=None."},timetz:{$meth:function(){return new k(this.$hour,this.$min,this.$sec,this.$micro,this.$tzinfo,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return time object with same time and tzinfo."},ctime:{$meth:function(){var t=this.$toOrdinal()%7||7,t=d[t],e=s[this.$month];return new $t(`${t} ${e} ${Mt(this.$day," ",2)} ${Mt(this.$hour,"0",2)}:${Mt(this.$min,"0",2)}:${Mt(this.$sec,"0",2)} `+Mt(this.$year,"0",4))},$flags:{NoArgs:!0},$textsig:null,$doc:"Return ctime() style string."},timetuple:{$meth:function(){let t=Q(this.tp$getattr(zt));return t=t===ct?-1:P(t)?1:0,w(this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return time tuple, compatible with time.localtime()."},timestamp:{$meth:function(){var t;return this.$tzinfo===ct?(t=this.$mkTime(),t=yt(t),new ot(t+this.$micro/1e6)):(t=bt(this,X,"Sub"),new ot((1e6*(86400*t.$days+t.$secs)+t.$micro)/1e6))},$flags:{NoArgs:!0},$textsig:null,$doc:"Return POSIX timestamp as float."},utctimetuple:{$meth:function(){var t=Q(this.tp$getattr(vt));let e=this;return w((e=P(t)?bt(e,t,"Sub"):e).$year,e.$month,e.$day,e.$hour,e.$min,e.$sec,0)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return UTC time tuple, compatible with time.localtime()."},isoformat:{$meth:function(t,e){if(!pt(t))throw new mt("sep must be str, not "+tt(t));let n=`${Mt(this.$year,"0",4)}-${Mt(this.$month,"0",2)}-`+Mt(this.$day,"0",2)+t.toString();n+=g(this.$hour,this.$min,this.$sec,this.$micro,e);t=p(Q(this.tp$getattr(vt)));return t&&(n+=t),new $t(n)},$flags:{NamedArgs:["sep","timespec"],Defaults:[new $t("T"),Ut]},$textsig:null,$doc:"[sep] -> string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\nsep is used to separate the year from the time, and defaults to 'T'.\ntimespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').\n"},utcoffset:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(vt),z("utcoffset",t=Q(t,[this])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.utcoffset(self)."},tzname:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(_t),j(t=Q(t,[this])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.tzname(self)."},dst:{$meth:function(){var t;return this.$tzinfo===ct?ct:(t=this.$tzinfo.tp$getattr(zt),z("dst",t=Q(t,[this])),t)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return self.tzinfo.dst(self)."},replace:{$meth:function(t,e){nt("replace",t,0,8);let[n,i,s,r,o,$,a,h,u]=st("replace",["year","month","day","hour","minute","second","microsecond","tzinfo","fold"],t,e,[ct,ct,ct,ct,ct,ct,ct,ut,ct]);return n===ct&&(n=new rt(this.$year)),i===ct&&(i=new rt(this.$month)),s===ct&&(s=new rt(this.$day)),r===ct&&(r=new rt(this.$hour)),o===ct&&(o=new rt(this.$min)),$===ct&&($=new rt(this.$sec)),a===ct&&(a=new rt(this.$micro)),h===ut&&(h=this.$tzinfo),u===ct&&(u=new rt(this.$fold)),this.ob$type.tp$call([n,i,s,r,o,$,a,h],["fold",u])},$flags:{FastCall:!0},$textsig:null,$doc:"Return datetime with new specified fields."},astimezone:{$meth:function(t){if(t===ct)t=this.$localTimezone();else if(!(t instanceof E))throw new mt("tz argument must be an instance of tzinfo");let e=this.$tzinfo,n;var i;return e===ct?(e=this.$localTimezone(),n=Q(e.tp$getattr(vt),[this])):(n=Q(e.tp$getattr(vt),[this]))===ct&&(e=Q(this.tp$getattr(At),[],["tzinfo",ct]).$localTimezone(),n=Q(e.tp$getattr(vt),[this])),t===e?this:(i=Q(this.nb$subtract(n).tp$getattr(At),[],["tzinfo",t]),t.tp$getattr(Bt).tp$call([i]))},$flags:{NamedArgs:["tz"],Defaults:[ct]},$textsig:null,$doc:"tz -> convert to local time in new timezone tz\n"},__reduce_ex__:{$meth(t){return new ht([this.ob$type,new ht(this.$getState(Ct(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:"__reduce_ex__(proto) -> (cls, state)"},__reduce__:{$meth(){return this.tp$getattr(new $t("__reduce_ex__")).tp$call([new rt(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:"__reduce__() -> (cls, state)"}},classmethods:{now:{$meth:function(t){var e=m.time.tp$call([]);return this.tp$getattr(jt).tp$call([e,t])},$flags:{NamedArgs:["tz"],Defaults:[ct]},$textsig:"($type, /, tz=None)",$doc:"Returns new datetime object representing current time local to tz.\n\n  tz\n    Timezone object.\n\nIf no tz is specified, uses local timezone."},utcnow:{$meth:function(){var t=m.time.tp$call([]);return this.tp$getattr(Ht).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a new datetime representing UTC day and time."},fromtimestamp:{$meth:function(t,e){return A(e),this.prototype.$fromtimestamp.call(this,t,e!==ct,e)},$flags:{NamedArgs:["timestamp","tz"],Defaults:[ct]},$textsig:null,$doc:"timestamp[, tz] -> tz's local time from POSIX timestamp."},utcfromtimestamp:{$meth:function(t){return this.prototype.$fromtimestamp.call(this,t,!0,ct)},$flags:{OneArg:!0},$textsig:null,$doc:"Construct a naive UTC datetime from a POSIX timestamp."},strptime:{$meth:function(e,n){return null===te?Sk.misceval.chain(Sk.importModule("_strptime",!1,!0),t=>(te=t.tp$getattr(new $t("_strptime_datetime"))).tp$call([this,e,n])):te.tp$call([this,e,n])},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:"string, format -> new datetime parsed from a string (like time.strptime())."},combine:{$meth:function(t,e,n){if(!(t instanceof I))throw new mt("date argument must be a date instance");if(!(e instanceof k))throw new mt("time argument must be a time instance");n===ut&&(n=e.$tzinfo);t=[t.$year,t.$month,t.$day,e.$hour,e.$min,e.$sec,e.$micro].map(t=>new rt(t));return t.push(n),this.tp$call(t,["fold",new rt(e.$fold)])},$flags:{NamedArgs:["date","time","tzinfo"],Defaults:[ut]},$textsig:null,$doc:"date, time -> datetime with same date and time fields"},fromisoformat:{$meth:function(e){if(!pt(e))throw new mt("fromisoformat: argument must be str");var t=(e=e.toString()).slice(0,10),n=e.slice(11);let i,s;try{i=b(t)}catch(t){throw new ft("Invalid isoformat string: '"+e+"'")}if(n)try{s=_(n)}catch(t){throw new ft("Invalid isoformat string: '"+e+"'")}else s=[xt,xt,xt,xt,ct];return this.tp$call(i.concat(s))},$flags:{OneArg:!0},$textsig:null,$doc:"string -> datetime from datetime.isoformat() output"}},getsets:{hour:{$get(){return new rt(this.$hour)}},minute:{$get(){return new rt(this.$min)}},second:{$get(){return new rt(this.$sec)}},microsecond:{$get(){return new rt(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new rt(this.$fold)}}},proto:{$cmp(t,e){var n=this.$tzinfo,i=t.$tzinfo;let s,r;s=r=ct;let o;if(n===i)o=!0;else{if(s=Q(this.tp$getattr(vt)),r=Q(t.tp$getattr(vt)),"Eq"===e||"NotEq"===e){n=Q(this.tp$getattr(At),[],["fold",new rt(Number(!this.$fold))]);if(W(s,Q(n.tp$getattr(vt)),"NotEq"))return 2;i=Q(t.tp$getattr(At),[],["fold",new rt(Number(!t.$fold))]);if(W(r,Q(i.tp$getattr(vt)),"NotEq"))return 2}o=W(s,r,"Eq")}if(o)return $([this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro],[t.$year,t.$month,t.$day,t.$hour,t.$min,t.$sec,t.$micro]);if(s===ct||r===ct){if("Eq"===e||"NotEq"===e)return 2;throw new mt("cannot compare naive and aware datetimes")}n=this.nb$subtract(t);return n.$days<0?-1:P(n)?1:0},$mkTime(){const o=new T(1970,1,1);var t=this.nb$subtract(o).nb$floor_divide(O);function e(t){var[t,e,n,i,s,r]=m.localtime.tp$call([t]).v;return T.tp$call([t,e,n,i,s,r]).nb$subtract(o).nb$floor_divide(O)}var n=e(t).nb$subtract(t),i=t.nb$subtract(n),s=e(i);let r,$;if(s.ob$eq(t)){if(r=i.nb$add([new rt(-86400),new rt(86400)][this.$fold]),$=e(r).nb$subtract(r),n.ob$eq($))return i}else $=s.nb$subtract(i);return e(r=t.nb$subtract($)).ob$eq(t)?r:s.ob$eq(t)?i:[n=i.ob$ge(r)?i:r,i===n?r:i][this.$fold]},$fromtimestamp(t,e,n){if(!kt(t))throw new mt("a number is required, (got '"+tt(t)+"'");[$,t]=ee(t);let i=Dt(bt($,Kt,"Mult"));i=i.v,t=t.v,1e6<=i?(t+=1,i-=1e6):i<0&&(--t,i+=1e6),t=new rt(t),Number.isInteger(i)||(i=Math.trunc(i)),i=new rt(i);const s=e?m.gmtime:m.localtime;function r(t){return s.tp$call([t]).v}var o,[$,e,a,h,u,c]=r(t),c=new rt(Math.min(K(c),59));let l=Q(this,[$,e,a,h,u,c,i,n]);return n===ct?([$,e,a,h,u,c]=r(bt(t,new rt(86400),"Sub")),o=Q(this,[$,e,a,h,u,c,i,n]),(o=bt(bt(l,o,"Sub"),new N(0,86400),"Sub")).$days<0&&([$,e,a,h,u,c]=r(bt(t,bt(o,O,"FloorDiv"),"Add")),t=Q(this,[$,e,a,h,u,c,i,n]),W(t,l,"Eq"))&&(l.$fold=1)):l=Q(n.tp$getattr(new $t("fromutc")),[l]),l},$localTimezone(){let t;t=this.$tzinfo===ct?this.$mkTime():this.nb$subtract(X).nb$floor_divide(O);var e=m.localtime.tp$call([t]),n=(T.tp$call(e.v.slice(0,6)),e.tp$getattr(new $t("tm_gmtoff"))),e=e.tp$getattr(new $t("tm_zone"));return new q(N.tp$call([xt,n]),e)},$getState(t=3){var[e,n]=St(this.$year,256),[i,s]=St(this.$micro,256),[i,r]=St(i,256);let o=this.$month;this.$fold&&3<t&&(o+=128);t=new at([e,n,o,this.$day,this.$hour,this.$min,this.$sec,i,r,s]);return this.$tzinfo===ct?[t]:[t,this.$tzinfo]},$setState(t,e){var[t,n,i,s,r,o,$,a,h,u]=t;127<i?(this.$fold=1,this.$month=i-128):(this.$fold=0,this.$month=i),this.$year=256*t+n,this.$day=s,this.$hour=r,this.$min=o,this.$sec=$,this.$micro=(a<<8|h)<<8|u,this.$tzinfo=e}}}));function R(t){var t=f(t,1,1),e=(t+6)%7;let n=t-e;return 3<e&&(n+=7),n}T.prototype.min=new T(1,1,1),T.prototype.max=new T(9999,12,31,23,59,59,999999),T.prototype.resolution=new N(0,0,1);const q=t.timezone=et("datetime.timezone",{base:E,constructor:function(t,e){if(this.$offset=t,this.$name=e||ct,!W(this.$minoffset,t,"LtE")||!W(this.$maxoffset,t,"GtE"))throw new ft("offset must be a timedelta strictly between -timedelta(hours=24) and timedelta(hours=24).")},slots:{tp$new(t,e){let[n,i]=st("timezone",["offset","name"],t,e,[null]);if(!(n instanceof N))throw new mt("offset must be a timedelta");if(null===i){if(!P(n))return this.utc;i=ct}else if(!pt(i))throw new mt("name must be a string");return this===q.prototype?new q(n,i):(t=new this.constructor,q.call(t,n,i),t)},tp$richcompare(t,e){return t instanceof q?(t=W(this.$offset,t.$offset,"Eq"),"NotEq"===e?!t:"Eq"===e||t&&It(e)?t:lt):lt},$r(){return this===this.utc?new $t("datetime.timezone.utc"):this.$name===ct?new $t(`${this.tp$name}(${V(this.$offset)})`):new $t(`${this.tp$name}(${V(this.$offset)}, ${V(this.$name)})`)},tp$str(){return this.tp$getattr(_t).tp$call([ct])},tp$hash(){return it(this.$offset)}},methods:{tzname:{$meth:function(t){if(t instanceof T||t===ct)return this.$name===ct?this.$nameFromOff(this.$offset):this.$name;throw new mt("tzname() argument must be a datetime instance or None")},$flags:{OneArg:!0},$textsig:null,$doc:"If name is specified when timezone is created, returns the name.  Otherwise returns offset as 'UTC(+|-)HH:MM'."},utcoffset:{$meth:function(t){if(t instanceof T||t===ct)return this.$offset;throw new mt("utcoffset() argument must be a datetime instance or None")},$flags:{OneArg:!0},$textsig:null,$doc:"Return fixed offset."},dst:{$meth:function(t){if(t instanceof T||t===ct)return ct;throw new mt("dst() argument must be a datetime instance or None")},$flags:{OneArg:!0},$textsig:null,$doc:"Return None."},fromutc:{$meth:function(t){if(t instanceof T){if(t.$tzinfo!==this)throw new ft("fromutc: dt.tzinfo is not self");return bt(t,this.$offset,"Add")}throw new mt("fromutc() argument must be a datetime instance or None")},$flags:{OneArg:!0},$textsig:null,$doc:"datetime in UTC -> datetime in local time."},__getinitargs__:{$meth(){return this.$name===ct?new ht([this.$offset]):new ht([this.$offset,this.$name])},$flags:{NoArgs:!0}}},proto:{$maxoffset:new N(0,86399,999999),$minoffset:new N(-1,0,1),$nameFromOff(t){if(!P(t))return new $t("UTC");let e,n,i,s,r,o;return W(t,B,"Lt")?(e="-",t=t.nb$negative()):e="+",[n,i]=Nt(t,S),[s,i]=Nt(i,M),r=i.$secs,(o=i.$micro)?new $t(`UTC${e}${Mt(n)}:${Mt(s)}:${Mt(r)}.`+Mt(o,"0",6)):r?new $t(`UTC${e}${Mt(n)}:${Mt(s)}:`+Mt(r)):new $t(`UTC${e}${Mt(n)}:`+Mt(s))}}}),X=(q.prototype.utc=new q(new N(0)),q.prototype.min=new q(new N(0,-86340,0)),q.prototype.max=new q(new N(0,86340,0)),new T(1970,1,1,0,0,0,0,q.prototype.utc));return t})}