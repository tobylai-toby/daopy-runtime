function $builtinmodule(T){const{builtin:{str:a,tuple:n,list:t,int_:i,bool:r,TypeError:o,ValueError:s,none:{none$:l},NotImplemented:{NotImplemented$:h},abs:e,len:u,checkString:c,checkInt:m},abstr:{buildNativeClass:d,checkNoKwargs:b,checkArgsLen:g,checkOneArg:f,numberUnaryOp:p,numberBinOp:$,numberInplaceBinOp:_,objectGetItem:w,objectDelItem:v,objectSetItem:x,sequenceConcat:A,sequenceContains:j,sequenceGetCountOf:O,sequenceGetIndexOf:C,sequenceInPlaceConcat:D,typeName:M,lookupSpecial:G,gattr:I,setUpModuleMethods:L},misceval:{richCompareBool:S,asIndexOrThrow:F,chain:y,callsimArray:P,callsimOrSuspendArray:U,objectRepr:k},generic:{getAttr:q}}=Sk;var R=["abs","add","and_","concat","contains","delitem","eq","floordiv","ge","getitem","gt","iadd","iand","iconcat","ifloordiv","ilshift","imatmul","imod","imul","index","inv","invert","ior","ipow","irshift","isub","itruediv","ixor","le","lshift","lt","matmul","mod","mul","ne","neg","not_","or_","pos","pow","rshift","setitem","sub","truediv","xor"],X=["attrgetter","countOf","indexOf","is_","is_not","itemgetter","length_hint","methodcaller","truth",...R].sort();const B={__name__:new a("operator"),__doc__:new a("Operator interface.\n\nThis module exports a set of functions implemented in javascript corresponding\nto the intrinsic operators of Python.  For example, operator.add(x, y)\nis equivalent to the expression x+y.  The function names are those\nused for special methods; variants without leading and trailing\n'__' are also provided for convenience."),__all__:new t(X.map(t=>new a(t)))},z=(B.itemgetter=d("operator.itemgetter",{constructor:function(t){this.items=t,this.oneitem=1===t.length,this.item=t[0],this.in$repr=!1},slots:{tp$getattr:q,tp$new(t,e){return b("itemgetter",e),g("itemgetter",t,1),new B.itemgetter(t)},tp$call(t,e){f("itemgetter",t,e);const r=t[0];return this.oneitem?w(r,this.item,!0):new n(this.items.map(t=>w(r,t)))},tp$doc:"Return a callable object that fetches the given item(s) from its operand.\n            After f = itemgetter(2), the call f(r) returns r[2].\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])",$r(){if(this.in$repr)return new a(this.tp$name+"(...)");this.in$repr=!0;var t=this.tp$name+"("+this.items.map(t=>k(t)).join(", ")+")";return this.in$repr=!1,t}}}),B.attrgetter=d("operator.attrgetter",{constructor:function(t){this.attrs=t,this.oneattr=1===t.length,this.attr=t[0],this.in$repr=!1},slots:{tp$getattr:q,tp$new(e,t){b("attrgetter",t),g("attrgetter",e,1);var r=[];for(let t=0;t<e.length;t++){var n=e[t];if(!c(n))throw new o("attribute name must be a string");var i=n.toString();i.includes(".")?r.push(i.split(".").map(t=>new a(t))):r.push([n])}return new B.attrgetter(r)},tp$call(t,e){f("attrgetter",t,e);const r=t[0];return this.oneattr?this.attr.reduce((t,e)=>I(t,e),r):(e=this.attrs.map(t=>t.reduce((t,e)=>I(t,e),r)),new n(e))},tp$doc:"attrgetter(attr, ...) --\x3e attrgetter object\n\nReturn a callable object that fetches the given attribute(s) from its operand.\nAfter f = attrgetter('name'), the call f(r) returns r.name.\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\n(r.name.first, r.name.last).",$r(){if(this.in$repr)return new a(this.tp$name+"(...)");this.in$repr=!0;var t=this.tp$name+"("+this.items.map(t=>k(t)).join(", ")+")";return this.in$repr=!1,t}}}),B.methodcaller=d("operator.methodcaller",{constructor:function(t,e,r){this.$name=t,this.args=e,this.kwargs=r||[],this.in$repr=!1},slots:{tp$getattr:q,tp$new(t,e){g("methodcaller",t,1);var r=t[0];if(c(r))return new B.methodcaller(r,t.slice(1),e);throw new o("method name must be a string")},tp$call(t,e){f("methodcaller",t,e);e=t[0];return y(I(e,this.$name,!0),t=>U(t,this.args,this.kwargs))},tp$doc:"methodcaller(name, ...) --\x3e methodcaller object\n\nReturn a callable object that calls the given method on its operand.\nAfter f = methodcaller('name'), the call f(r) returns r.name().\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\nr.name('date', foo=1).",$r(){if(this.in$repr)return new a(this.tp$name+"(...)");this.in$repr=!0;let e=[k(this.$name)];e.push(...this.args.map(t=>k(t)));for(let t=0;t<this.kwargs.length;t+=2)e.push(this.kwargs[t]+"="+k(this.kwargs[t+1]));return e=this.tp$name+"("+e.join(", ")+")",this.in$repr=!1,e}}}),{1:{$flags:{OneArg:!0},$textsig:"($module, a, /)"},2:{$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, a, b, /)"},3:{$flags:{MinArgs:3,MaxArgs:3},$textsig:"($module, a, b, c, /)"}});function N(t,e){return{$meth:t,$doc:e,...z[t.length]}}function E(t){return"Same as "+t+"."}return L("operator",B,{lt:N((t,e)=>r(S(t,e,"Lt")),E("a < b")),le:N((t,e)=>r(S(t,e,"LtE")),E("a <= b")),eq:N((t,e)=>r(S(t,e,"Eq")),E("a == b")),ne:N((t,e)=>r(S(t,e,"NotEq")),E("a != b")),ge:N((t,e)=>r(S(t,e,"GtE")),E("a >= b")),gt:N((t,e)=>r(S(t,e,"Gt")),E("a > b")),not_:N(t=>p(t,"Not"),E("not a")),truth:N(t=>r(t),"Return True if a is true, False otherwise."),is_:N((t,e)=>r(S(t,e,"Is")),E("a is b")),is_not:N((t,e)=>r(S(t,e,"IsNot")),E("a is not b")),abs:N(t=>e(t),E("abs(a)")),add:N((t,e)=>$(t,e,"Add"),E("a + b")),and_:N((t,e)=>$(t,e,"BitAnd"),E("a & b")),floordiv:N((t,e)=>$(t,e,"FloorDiv"),E("a // b")),index:N(t=>new i(F(t)),E("a.__index__()")),inv:N(t=>p(t,"Invert"),E("~a")),invert:N(t=>p(t,"Invert"),E("~a")),lshift:N((t,e)=>$(t,e,"LShift"),E("a << b")),mod:N((t,e)=>$(t,e,"Mod"),E("a % b")),mul:N((t,e)=>$(t,e,"Mult"),E("a * b")),matmul:N((t,e)=>$(t,e,"MatMult"),E("a @ b")),neg:N(t=>p(t,"USub"),E("-a")),or_:N((t,e)=>$(t,e,"BitOr"),E("a | b")),pos:N(t=>p(t,"UAdd"),E("+a")),pow:N((t,e)=>$(t,e,"Pow"),E("a ** b")),rshift:N((t,e)=>$(t,e,"RShift"),E("a >> b")),sub:N((t,e)=>$(t,e,"Sub"),E("a - b")),truediv:N((t,e)=>$(t,e,"Div"),E("a / b")),xor:N((t,e)=>$(t,e,"BitXor"),E("a ^ b")),concat:N((t,e)=>A(t,e),E("a + b, for a and b sequences")),contains:N((t,e)=>y(j(t,e),r),E("b in a (note reversed operands)")),countOf:N((t,e)=>O(t,e),"Return thenumber of times b occurs in a."),delitem:N((t,e)=>y(v(t,e,!0),()=>l),E("del a[b]")),getitem:N((t,e)=>w(t,e,!0),E("a[b]")),indexOf:N((t,e)=>C(t,e),"Return the first index of b in a"),setitem:N((t,e,r)=>y(x(t,e,r,!0),()=>l),E("a[b] = c")),length_hint:{$meth:function(t,e){if(void 0===e)e=new i(0);else if(!m(e))throw new o("'"+M(e)+"' object cannot be interpreted as an integer");try{return u(t)}catch(t){if(!(t instanceof o))throw t}t=G(t,a.$length_hint);if(void 0===t)return e;let r;try{r=P(t,[])}catch(t){if(t instanceof o)return e;throw t}if(r===h)return e;if(!m(r))throw new o("__length_hint__ must be an integer, not "+M(r));if(r.nb$isnegative())throw new s("__length_hint__() should return >= 0");return r},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, obj, default=0, /)",$doc:"Return an estimate of the number of items in obj.\n\nThis is useful for presizing containers when building from an iterable.\n\nIf the object supports len(), the result will be exact.\nOtherwise, it may over- or under-estimate by an arbitrary amount.\nThe result will be an integer >= 0."},iadd:N((t,e)=>_(t,e,"Add"),E("a += b")),iand:N((t,e)=>_(t,e,"BitAnd"),E("a &= b")),iconcat:N((t,e)=>D(t,e),E("a += b, for a and b sequences")),ifloordiv:N((t,e)=>_(t,e,"FloorDiv"),E("a //= b")),ilshift:N((t,e)=>_(t,e,"LShift"),E("a <<= b")),imod:N((t,e)=>_(t,e,"Mod"),E("a %= b")),imul:N((t,e)=>_(t,e,"Mult"),E("a *= b")),imatmul:N((t,e)=>_(t,e,"MatMult"),E("a @= b")),ior:N((t,e)=>_(t,e,"BitOr"),E("a |= b")),ipow:N((t,e)=>_(t,e,"Pow"),E("a **= b")),irshift:N((t,e)=>_(t,e,"RShift"),E("a >>= b")),isub:N((t,e)=>_(t,e,"Sub"),E("a -= b")),itruediv:N((t,e)=>_(t,e,"Div"),E("a /= b")),ixor:N((t,e)=>_(t,e,"BitXor"),E("a ^= b"))}),R.forEach(t=>{B[`__${t.replace("_","")}__`]=B[t]}),B.div=B.truediv,B.__div__=B.div,B}