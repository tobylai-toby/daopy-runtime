function $builtinmodule(t){const e={};return Sk.misceval.chain(Sk.importModule("math",!1,!0),t=>(e.math=t,Sk.importModule("sys",!1,!0)),t=>(e.sys=t,fractionsMod(e)))}function fractionsMod({math:t,sys:e}){const{builtin:{int_:o,bool:{true$:T,false$:n},none:{none$:a},NotImplemented:{NotImplemented$:r},tuple:s,float_:u,complex:$,str:h,isinstance:R,TypeError:m,ZeroDivisionError:B,ValueError:C,NotImplementedError:K,abs:d,round:L,pow:P},ffi:{remapToPy:j},abstr:{buildNativeClass:G,copyKeywordsToNamedArgs:V,numberBinOp:i,typeName:Z,lookupSpecial:H,checkArgsLen:J},misceval:{isTrue:l,richCompareBool:f,callsimArray:c,objectRepr:Q}}=Sk;var U={__name__:new h("fractions"),__all__:j(["Fraction"])};const W=/^\s*(?<sign>[-+]?)(?=\d|\.\d)(?<num>\d*)(?:(?:\/(?<denom>\d+))?|(?:\.(?<decimal>\d*))?(?:E(?<exp>[-+]?\d+))?)\s*$/i,b=new o(0),_=new o(1),g=new o(2),p=new o(10),X=new h("numerator"),Y=new h("denominator"),tt=new h("as_integer_ratio"),et=new h("from_float"),w=t=>t.tp$getattr(X),v=t=>t.tp$getattr(Y),y=(t,e)=>i(t,e,"Mult"),E=(t,e)=>i(t,e,"Div"),N=(t,e)=>i(t,e,"Pow"),F=(t,e)=>i(t,e,"Add"),k=(t,e)=>i(t,e,"Sub"),A=(t,e)=>i(t,e,"FloorDiv"),S=(t,e)=>i(t,e,"DivMod"),M=(t,e)=>i(t,e,"Mod"),nt=t.tp$getattr(new h("gcd")),O=(t,e)=>f(t,e,"Eq"),D=(t,e)=>f(t,e,"Lt"),q=(t,e)=>f(t,e,"GtE");var t={NoArgs:!0},it={OneArg:!0},e=e.tp$getattr(new h("hash_info"));const rt=e.tp$getattr(new h("modulus")),st=e.tp$getattr(new h("inf"));function x(e,n){return[function(t){return I(t)?e(this,t):t instanceof u?n(this.nb$float(),t):t instanceof $?n(c($,[this]),t):r},function(t){return I(t)?e(t,this):t instanceof u?n(t,this.nb$float()):t instanceof $?n(t,c($,[this])):r}]}var[e,$t]=x((t,e)=>{var n=v(t),i=v(e);return c(z,[F(y(w(t),i),y(w(e),n)),y(n,i)])},F),[ot,at]=x((t,e)=>{var n=v(t),i=v(e);return c(z,[k(y(w(t),i),y(w(e),n)),y(n,i)])},k),[ut,ht]=x((t,e)=>c(z,[y(w(t),w(e)),y(v(t),v(e))]),y),[mt,dt]=x((t,e)=>c(z,[y(w(t),v(e)),y(v(t),w(e))]),E),[lt,ft]=x((t,e)=>A(y(w(t),v(e)),y(v(t),w(e))),A),[ct,bt]=x((t,e)=>{var n=v(t),i=v(e),[t,e]=S(y(w(t),i),y(n,w(e))).valueOf();return new s([t,c(z,[e,y(n,i)])])},S),[_t,gt]=x((t,e)=>{var n=v(t),i=v(e),t=M(y(w(t),i),y(w(e),n));return c(z,[t,y(n,i)])},M);const z=U.Fraction=G("fractions.Fraction",{constructor:function(t,e){this.$num=t||b,this.$den=e||_},slots:{tp$new(t,e){J("Fraction",t,0,2);let[n,i,r]=V("Fraction",["numerator","denominator","_normalize"],t,e,[b,a,T]);t=new this.constructor;if(i===a){if(n.ob$type===o)return t.$num=n,t.$den=_,t;if(I(n))return t.$num=w(n),t.$den=v(n),t;if(n instanceof u)return[t.$num,t.$den]=c(n.tp$getattr(tt)).valueOf(),t;if(!(n instanceof h))throw new m("argument should be a string or a Rational instance");e=n.toString().match(W);if(null===e)throw new C("Invalid literal for Fraction: "+Q(n));n=new o(e.groups.num||"0");var s,$=e.groups.denom;$?i=new o($):(i=_,($=e.groups.decimal)&&(s=new o(""+10**$.length),n=F(y(n,s),new o($)),i=y(i,s)),($=e.groups.exp)&&($=new o($),D($,b)?i=y(i,N(p,$.nb$negative())):n=y(n,N(p,$)))),"-"==e.groups.sign&&(n=n.nb$negative())}else if(n.ob$type!==o||i.ob$type!==o){if(!I(n)||!I(i))throw new m("both arguments should be Rational instances");[n,i]=[y(w(n),v(i)),y(w(i),v(n))]}if(O(i,b))throw new B(`Fraction(${n}, 0)`);if(l(r)){let t=c(nt,[n,i]);D(i,b)&&(t=t.nb$negative()),n=A(n,t),i=A(i,t)}return t.$num=n,t.$den=i,t},$r(){var t=H(this.ob$type,h.$name);return new h(`${t}(${this.$num}, ${this.$den})`)},tp$str(){return O(this.$den,_)?new h(this.$num):new h(this.$num+"/"+this.$den)},tp$hash(){var t=P(this.$den,k(rt,g),rt);let e,n=(e=l(t)?M(y(d(this.$num),t),rt):st,q(this,b)?e:e.nb$negative());return-1===(n=n.tp$hash())?-2:n},tp$richcompare(t,n){var e,i=(t,e)=>f(t,e,n);if("Eq"===n||"NotEq"==n){if(t.ob$type===o)return e=O(this.$num,t)&&O(this.$den,_),"Eq"===n?e:!e;if(t instanceof z||t instanceof o)return e=O(this.$num,w(t))&&O(this.$den,v(t)),"Eq"===n?e:!e;t instanceof $&&O(t.tp$getattr(new h("imag")),b)&&(t=t.tp$getattr(new h("real")))}return I(t)?i(y(w(this),v(t)),y(v(this),w(t))):t instanceof u?Number.isFinite(t.valueOf())?i(this,c(this.tp$getattr(et),[t])):i(new u(0),t):r},tp$as_number:!0,nb$add:e,nb$reflected_add:$t,nb$subtract:ot,nb$reflected_subtract:at,nb$multiply:ut,nb$reflected_multiply:ht,nb$divide:mt,nb$reflected_divide:dt,nb$floor_divide:lt,nb$reflected_floor_divide:ft,nb$divmod:ct,nb$reflected_divmod:bt,nb$remainder:_t,nb$reflected_remainder:gt,nb$power(e){if(I(e)){if(O(v(e),_)){let t=w(e);return q(t,b)?c(z,[N(this.$num,t),N(this.$den,t)],["_normalize",n]):q(this.$num,b)?(t=t.nb$negative(),c(z,[N(this.$den,t),N(this.$num,t)],["_normalize",n])):(t=t.nb$negative(),c(z,[N(this.$den.nb$negative(),t),N(this.$num.nb$negative(),t)],["_normalize",n]))}return N(this.nb$float(),c(u,[e]))}return N(this.nb$float(),e)},nb$reflected_power(t){return O(this.$den,_)&&q(this.$num,b)?N(t,this.$num):I(t)?N(new z(w(t),v(t)),this):O(this.$den,_)?N(t,this.$num):N(t,this.nb$float())},nb$positive(){return new z(this.$num,this.$den)},nb$negative(){return new z(this.$num.nb$negative(),this.$den)},nb$abs(){return new z(this.$num.nb$abs(),this.$den)},nb$bool(){return this.$num.nb$bool()},nb$float(){return E(this.$num,this.$den)}},methods:{as_integer_ratio:{$meth(){return new s([this.$num,this.$den])},$flags:t},limit_denominator:{$meth(t){if(D(t,_))throw new C("max_denominator should be at least 1");if(q(t,this.$den))return c(z,[this]);let[e,n,i,r]=[b,_,_,b],s=this.$num,$=this.$den;for(;;){var o=A(s,$),a=F(n,y(o,r));if(D(t,a))break;[e,n,i,r]=[i,r,F(e,y(o,i)),a],[s,$]=[$,k(s,y(o,$))]}var u=A(k(t,n),r),u=c(z,[F(e,y(u,i)),F(n,y(u,r))]),h=c(z,[i,r]);return q(d(k(u,this)),d(k(h,this)))?h:u},$flags:{NamedArgs:["max_denominator"],Defaults:[new o(1e6)]}},__trunc__:{$meth(){return D(this.$num,b)?A(this.$num.nb$negative(),this.$den).nb$negative():A(this.$num,this.$den)},$flags:t},__floor__:{$meth(){return A(this.$num,this.$den)},$flags:t},__ceil__:{$meth(){return A(this.$num.nb$negative(),this.$den).nb$negative()},$flags:t},__round__:{$meth(t){var e,n;return t===a?([e,n]=S(this.$num,this.$den).valueOf(),n=y(n,g),D(n,this.$den)||!D(this.$den,n)&&O(M(e,g),b)?e:F(e,_)):(n=N(p,d(t)),D(b,t)?c(z,[L(y(this,n)),n]):c(z,[y(L(E(this,n)),n)]))},$flags:{NamedArgs:["ndigits"],Defaults:[a]}},__reduce__:{$meth(){return new s([this.ob$type,new s([new h(this)])])},$flags:t},__copy__:{$meth(){return this.ob$type===z?this:c(this.ob$type,[this.$num,this.$den])},$flags:t},__deepcopy__:{$meth(t){return this.ob$type===z?this:c(this.ob$type,[this.$num,this.$den])},$flags:it}},classmethods:{from_float:{$meth(t){if(t instanceof o)return c(this,[t]);var e,n;if(t instanceof u)return[e,n]=c(t.tp$getattr(tt)).valueOf(),c(this,[e,n]);throw new m(`${Z(this)}.from_float() only takes floats, not ${Q(t)}, (${Z(t)})`)},$flags:it},from_decimal:{$meth(){throw K("from_decimal not yet implemented in SKulpt")},$flags:it}},getsets:{numerator:{$get(){return this.$num}},denominator:{$get(){return this.$den}},_numerator:{$get(){return this.$num},$set(t){this.$num=t}},_denominator:{$get(){return this.$den},$set(t){this.$den=t}}}}),pt=new s([o,z]),I=t=>l(R(t,pt));return U}