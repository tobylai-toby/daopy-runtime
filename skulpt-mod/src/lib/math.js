const $builtinmodule=function(e){const{builtin:{str:n,int_:i,float_:r,TypeError:u,pyCheckType:l,checkNumber:a},abstr:{lookupSpecial:o},misceval:{callsimOrSuspendArray:s}}=Sk;var t={pi:new Sk.builtin.float_(Math.PI),e:new Sk.builtin.float_(Math.E),tau:new Sk.builtin.float_(2*Math.PI),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(1/0)};const b=new n("__ceil__");function m(e){return e=e?e<0?-1:1:1/e<0?-1:1}function h(t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(t));var e=Sk.builtin.asnum$(t);if((t=Math.floor(e))!=e)throw new Sk.builtin.ValueError("factorial() only accepts integral values");if(t<0)throw new Sk.builtin.ValueError("factorial() not defined for negative numbers");let n=1;for(let e=2;e<=t&&e<=18;e++)n*=e;if(!(t<=18)){n=JSBI.BigInt(n);for(let e=19;e<=t;e++)n=JSBI.multiply(n,JSBI.BigInt(e))}return new Sk.builtin.int_(n)}const k=new n("__floor__");function f(e,t){let n;return"number"==typeof e&&"number"==typeof t?(e=Math.abs(e),t=Math.abs(t),n=(n=function e(t,n){return 0==n?t:e(n,t%n)}(e,t))<0?-n:n):(e=JSBI.BigInt(e),t=JSBI.BigInt(t),n=function e(t,n){return JSBI.equal(n,JSBI.__ZERO)?t:e(n,JSBI.remainder(t,n))}(e,t),JSBI.lessThan(n,JSBI.__ZERO)&&(n=JSBI.multiply(n,JSBI.BigInt(-1)))),n}return Sk.abstr.setUpModuleMethods("math",t,{acos:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the arc cosine (measured in radians) of x."},acosh:{$meth:function(e){return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e-1),new Sk.builtin.float_(Math.log(e))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the inverse hyperbolic cosine of x."},asin:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the arc sine (measured in radians) of x."},asinh:{$meth:function(e){return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e+1),new Sk.builtin.float_(Math.log(e))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the inverse hyperbolic sine of x."},atan:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the arc tangent (measured in radians) of x."},atan2:{$meth:function(e,t){return Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(t)),new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, y, x, /)",$doc:"Return the arc tangent (measured in radians) of y/x.\n\nUnlike atan(y/x), the signs of both x and y are considered."},atanh:{$meth:function(e){return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e),new Sk.builtin.float_(Math.log((1+e)/(1-e))/2)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the inverse hyperbolic tangent of x."},ceil:{$meth:function(e){let t;if(e.ob$type!==r){var n=o(e,b);if(void 0!==n)return s(n);l("","real number",a(e)),t=Sk.builtin.asnum$(e)}else t=e.v;return new i(Math.ceil(t))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the ceiling of x as an Integral.\n\nThis is the smallest integer >= x."},comb:{$meth:function(t,e){var n=Sk.misceval.asIndexOrThrow(t);let i=Sk.misceval.asIndexOrThrow(e);if(n<0)throw new Sk.builtin.ValueError("n must be an non-negative integer");if(i<0)throw new Sk.builtin.ValueError("k must be a non-negative integer");if(i>t)return new Sk.builtin.int_(0);t=new Sk.builtin.int_(n),e=new Sk.builtin.int_(i);let r=Sk.ffi.remapToJs(t.nb$subtract(e));if(0===(i=r<i?r:i))return new Sk.builtin.int_(1);if(i>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError("min(n - k, k) must not exceed "+Number.MAX_SAFE_INTEGER);var u=new Sk.builtin.int_(1);let l=t;for(let e=1;e<i;e++)t=t.nb$subtract(u),r=new Sk.builtin.int_(e+1),l=(l=l.nb$multiply(t)).nb$floor_divide(r);return l},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, n, k=None, /)",$doc:"Number of ways to choose k items from n items without repetition and with order.\n\nEvaluates to n! / (n - k)! when k <= n and evaluates\nto zero when k > n.\n\nIf k is not specified or is None, then k defaults to n\nand the function returns n!.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative."},copysign:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(t));var t=Sk.builtin.asnum$(t),e=Sk.builtin.asnum$(e),n=m(e),t=m(t);return new Sk.builtin.float_(e*(n*t))},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return a float with the magnitude (absolute value) of x but the sign of y.\n\nOn platforms that support signed zeros, copysign(1.0, -0.0)\nreturns -1.0.\n"},cos:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the cosine of x (measured in radians)."},cosh:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);var t=Math.E,t=Math.pow(t,e);return new Sk.builtin.float_((t+1/t)/2)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the hyperbolic cosine of x."},degrees:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),e=180/Math.PI*Sk.builtin.asnum$(e),new Sk.builtin.float_(e)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Convert angle x from radians to degrees."},erf:{$meth:function(e){throw new Sk.builtin.NotImplementedError("math.erf() is not yet implemented in Skulpt")},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Error function at x."},erfc:{$meth:function(e){throw new Sk.builtin.NotImplementedError("math.erfc() is not yet implemented in Skulpt")},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Complementary error function at x."},exp:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));let t=e.v;if((t="number"!=typeof t?e.nb$float().v:t)==1/0||t==-1/0||isNaN(t))return new Sk.builtin.float_(Math.exp(t));if(e=Math.exp(t),isFinite(e))return new Sk.builtin.float_(e);throw new Sk.builtin.OverflowError("math range error")},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return e raised to the power of x."},expm1:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var t,e=Sk.builtin.asnum$(e);return Math.abs(e)<.7?1==(t=Math.exp(e))?new Sk.builtin.float_(e):(t=(t-1)*e/Math.log(t),new Sk.builtin.float_(t)):(t=Math.exp(e)-1,new Sk.builtin.float_(t))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return exp(x)-1.\n\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x."},fabs:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));let t=e.v;return JSBI.__isBigInt(t)&&(t=e.nb$float().v),t=Math.abs(t),new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the absolute value of the float x."},factorial:{$meth:h,$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Find x!.\n\nRaise a ValueError if x is negative or non-integral."},floor:{$meth:function(e){let t;if(e.ob$type===r)t=e.v;else{var n=o(e,k);if(void 0!==n)return s(n);l("x","number",a(e)),t=Sk.builtin.asnum$(e)}return new i(Math.floor(t))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the floor of x as an Integral.\n\nThis is the largest integer <= x."},fmod:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if("number"!=typeof n&&(n=e.nb$float().v),((i="number"!=typeof i?t.nb$float().v:i)==1/0||i==-1/0)&&isFinite(n))return new Sk.builtin.float_(n);if(e=n%i,!isNaN(e)||isNaN(n)||isNaN(i))return new Sk.builtin.float_(e);throw new Sk.builtin.ValueError("math domain error")},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return fmod(x, y), according to platform C.\n\nx % y may differ."},frexp:{$meth:function(n){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(n));var i=[n=Sk.builtin.asnum$(n),0];if(0!==n&&Number.isFinite(n)){var r=Math.abs(n);let e=Math.max(-1023,Math.floor(Math.log2(r))+1),t=r*Math.pow(2,-e);for(;t<.5;)t*=2,e--;for(;1<=t;)t*=.5,e++;n<0&&(t=-t),i[0]=t,i[1]=e}return i[0]=new Sk.builtin.float_(i[0]),i[1]=new Sk.builtin.int_(i[1]),new Sk.builtin.tuple(i)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the mantissa and exponent of x, as pair (m, e).\n\nm is a float and e is an int, such that x = m * 2.**e.\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0."},fsum:{$meth:function(e){if(!Sk.builtin.checkIterable(e))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(e)+"' object is not iterable");let i=[],r,u,l;for(let n=(e=Sk.abstr.iter(e)).tp$iternext();void 0!==n;n=e.tp$iternext()){Sk.builtin.pyCheckType("","real number",Sk.builtin.checkNumber(n)),r=0;let e=n.v;"number"!=typeof e&&(e=n.nb$float().v),n=e;for(let t=0,e=i.length;t<e;t++){let e=i[t];var a;Math.abs(n)<Math.abs(e)&&(a=n,n=e,e=a),u=n+e,(l=e-(u-n))&&(i[r]=l,r++),n=u}i=i.slice(0,r).concat([n])}var t=i.reduce(function(e,t){return e+t},0);return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:"($module, seq, /)",$doc:"Return an accurate floating point sum of values in the iterable seq.\n\nAssumes IEEE-754 floating point arithmetic."},gamma:{$meth:function(e){throw new Sk.builtin.NotImplementedError("math.gamma() is not yet implemented in Skulpt")},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Gamma function at x."},gcd:{$meth:function(e,t){return Sk.builtin.pyCheckType("a","integer",Sk.builtin.checkInt(e)),Sk.builtin.pyCheckType("b","integer",Sk.builtin.checkInt(t)),"number"==typeof(e=f(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t)))?new Sk.builtin.int_(e):new Sk.builtin.int_(e.toString())},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"greatest common divisor of x and y"},hypot:{$meth:function(e,t){return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(t)),e=Sk.builtin.asnum$(e),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(Math.sqrt(e*e+t*t))},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return the Euclidean distance, sqrt(x*x + y*y)."},isclose:{$meth:function(e,t){Sk.abstr.checkArgsLen("isclose",e,2,2);var n,t=Sk.abstr.copyKeywordsToNamedArgs("isclose",["rel_tol","abs_tol"],[],t,[new Sk.builtin.float_(1e-9),new Sk.builtin.float_(0)]),i=e[0],e=e[1],r=t[0],t=t[1],i=(Sk.builtin.pyCheckType("a","number",Sk.builtin.checkNumber(i)),Sk.builtin.pyCheckType("b","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("rel_tol","number",Sk.builtin.checkNumber(r)),Sk.builtin.pyCheckType("abs_tol","number",Sk.builtin.checkNumber(t)),Sk.builtin.asnum$(i)),e=Sk.builtin.asnum$(e),r=Sk.builtin.asnum$(r),t=Sk.builtin.asnum$(t);if(r<0||t<0)throw new Sk.builtin.ValueError("tolerances must be non-negative");return i==e?Sk.builtin.bool.true$:i==1/0||i==-1/0||e==1/0||e==-1/0?Sk.builtin.bool.false$:(e=(n=Math.abs(e-i))<=Math.abs(r*e)||n<=Math.abs(r*i)||n<=t,new Sk.builtin.bool(e))},$flags:{FastCall:!0},$textsig:"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)",$doc:'Determine whether two floating point numbers are close in value.\n\n  rel_tol\n    maximum difference for being considered "close", relative to the\n    magnitude of the input values\n  abs_tol\n    maximum difference for being considered "close", regardless of the\n    magnitude of the input values\n\nReturn True if a is close in value to b, and False otherwise.\n\nFor the values to be considered close, the difference between them\nmust be smaller than at least one of the tolerances.\n\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\nis, NaN is not close to anything, even itself.  inf and -inf are\nonly close to themselves.'},isfinite:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return True if x is neither an infinity nor a NaN, and False otherwise."},isinf:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)||isNaN(t)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return True if x is a positive or negative infinity, and False otherwise."},isnan:{$meth:function(e){return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e),isNaN(e)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return True if x is a NaN (not a number), and False otherwise."},isqrt:{$meth:function(r){if((r=Sk.misceval.asIndexOrThrow(r))<0)throw new Sk.builtin.ValueError("isqrt() argument must be nonnegative");if(0==r)return new Sk.builtin.int_(0);if("number"==typeof r)return new Sk.builtin.int_(Math.floor(Math.sqrt(r)));{var u=r;r=u.toString(2).length;let e=(r=Math.floor((r-1)/2)).toString(2).length;var l=JSBI.BigInt(1),a=JSBI.BigInt(2),o=JSBI.BigInt(r),s=JSBI.multiply(a,o);let t=l,n=JSBI.BigInt(0);for(;0<e;){e--;var b=n,m=(n=JSBI.signedRightShift(o,JSBI.BigInt(e)),JSBI.subtract(JSBI.subtract(n,b),l)),m=JSBI.leftShift(t,m),b=JSBI.add(JSBI.subtract(JSBI.subtract(s,b),n),l),b=JSBI.signedRightShift(u,b);t=JSBI.add(m,JSBI.divide(b,t))}let i=t;return JSBI.greaterThan(JSBI.multiply(i,i),u)&&(i=JSBI.subtract(i,l)),JSBI.lessThanOrEqual(i,JSBI.BigInt(Number.MAX_SAFE_INTEGER))&&(i=Number(i)),new Sk.builtin.int_(i);return}},$flags:{OneArg:!0},$textsig:"($module, n, /)",$doc:"Return the integer part of the square root of the input."},lcm:{$meth:function(...e){function t(e){return"number"==typeof e?new Sk.builtin.int_(Math.abs(e)):JSBI.lessThan(e,JSBI.__ZERO)?new Sk.builtin.int_(JSBI.unaryMinus(e)):new Sk.builtin.int_(e)}var n,i,r=e.length;if(0===r)return new Sk.builtin.int_(1);let u;for(u=0;u<r;++u)e[u]=Sk.misceval.asIndexOrThrow(e[u]);let l=e[0];if(1!==r)for(u=1;u<r;++u){if(0===(n=e[u]))return new Sk.builtin.int_(0);"number"!=typeof(l="number"!=typeof l||"number"!=typeof n||(i=l/f(l,n)*n,(i=Math.abs(i))>Number.MAX_SAFE_INTEGER)?JSBI.BigInt(l):i)&&(n=JSBI.BigInt(n),l=JSBI.multiply(JSBI.divide(l,f(l,n)),n))}return t(l)},$flags:{MinArgs:0},$textsig:"($module, *integers, /)",$doc:"Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1."},ldexp:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("i","integer",Sk.builtin.checkInt(t));let n=e.v;if("number"!=typeof n&&(n=e.nb$float().v),e=Sk.builtin.asnum$(t),n==1/0||n==-1/0||0==n||isNaN(n))return new Sk.builtin.float_(n);if(t=n*Math.pow(2,e),isFinite(t))return new Sk.builtin.float_(t);throw new Sk.builtin.OverflowError("math range error")},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, i, /)",$doc:"Return x * (2**i).\n\nThis is essentially the inverse of frexp()."},lgamma:{$meth:function(e){throw new Sk.builtin.NotImplementedError("math.lgamma() is not yet implemented in Skulpt")},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Natural logarithm of absolute value of Gamma function at x."},log:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var n=Sk.builtin.asnum$(e);let i,r;if(n<=0)throw new Sk.builtin.ValueError("math domain error");if((i=void 0===t?Math.E:(Sk.builtin.pyCheckType("base","number",Sk.builtin.checkNumber(t)),Sk.builtin.asnum$(t)))<=0)throw new Sk.builtin.ValueError("math domain error");return r=Sk.builtin.checkFloat(e)||n<Number.MAX_SAFE_INTEGER?Math.log(n)/Math.log(i):(t=(n=new Sk.builtin.str(e).$jsstr()).length,e=parseFloat("0."+n),(t*Math.log(10)+Math.log(e))/Math.log(i)),new Sk.builtin.float_(r)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"log(x, [base=e])\nReturn the logarithm of x to the given base.\n\nIf the base not specified, returns the natural logarithm (base e) of x."},log10:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var t=Sk.builtin.asnum$(e);let n;if(t<=0)throw new Sk.builtin.ValueError("math domain error");return n=Sk.builtin.checkFloat(e)||t<Number.MAX_SAFE_INTEGER?Math.log10(t):(e=(t=new Sk.builtin.str(e).$jsstr()).length,t=parseFloat("0."+t),e+Math.log10(t)),new Sk.builtin.float_(n)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the base 10 logarithm of x."},log1p:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));let t=e.v;if((t="number"!=typeof t?e.nb$float().v:t)<=-1)throw new Sk.builtin.ValueError("math domain error");return 0==t||Math.abs(t)<Number.EPSILON/2?new Sk.builtin.float_(t):-.5<=t&&t<=1?(e=1+t,e=Math.log(e)-(e-1-t)/e,new Sk.builtin.float_(e)):(e=Math.log(1+t),new Sk.builtin.float_(e))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the natural logarithm of 1+x (base e).\n\nThe result is computed in a way which is accurate for x near zero."},log2:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e));var t=Sk.builtin.asnum$(e);let n;if(t<=0)throw new Sk.builtin.ValueError("math domain error");return n=Sk.builtin.checkFloat(e)||t<Number.MAX_SAFE_INTEGER?Math.log2(t):(e=(t=new Sk.builtin.str(e).$jsstr()).length,t=parseFloat("0."+t),e*Math.log2(10)+Math.log2(t)),new Sk.builtin.float_(n)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the base 2 logarithm of x."},modf:{$meth:function(e){if(Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e),!isFinite(e)){if(e==1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(e)]);if(e==-1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),new Sk.builtin.float_(e)]);if(isNaN(e))return new Sk.builtin.tuple([new Sk.builtin.float_(e),new Sk.builtin.float_(e)])}var t=m(e),e=Math.abs(e),n=t*Math.floor(e),t=t*(e-Math.floor(e));return new Sk.builtin.tuple([new Sk.builtin.float_(t),new Sk.builtin.float_(n)])},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the fractional and integer parts of x.\n\nBoth results carry the sign of x and are floats."},perm:{$meth:function(t,n){if(void 0===n||Sk.builtin.checkNone(n))return h(t);if(t=Sk.misceval.asIndexOrThrow(t),n=Sk.misceval.asIndexOrThrow(n),t<0)throw new Sk.builtin.ValueError("n must be an non-negative integer");if(n<0)throw new Sk.builtin.ValueError("k must be a non-negative integer");if(t<n)return new Sk.builtin.int_(0);if(0===n)return new Sk.builtin.int_(1);if(n>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError("k must not exceed "+Number.MAX_SAFE_INTEGER);var i=new Sk.builtin.int_(1);let r=t=new Sk.builtin.int_(t);for(let e=1;e<n;e++)t=t.nb$subtract(i),r=r.nb$multiply(t);return r},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, n, k=None, /)",$doc:"'Number of ways to choose k items from n items without repetition and with order.\n\nEvaluates to n! / (n - k)! when k <= n and evaluates\nto zero when k > n.\n\nIf k is not specified or is None, then k defaults to n\nand the function returns n!.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative.'"},prod:{$meth:function(e,t){Sk.abstr.checkArgsLen("prod",e,1,1),e=Sk.abstr.copyKeywordsToNamedArgs("prod",[null,"start"],e,t,[new Sk.builtin.int_(1)]);const n=Sk.abstr.iter(e[0]);let i=e[1],r;return r=i.constructor===Sk.builtin.int_?Sk.misceval.iterFor(n,e=>{if(e.constructor!==Sk.builtin.int_)return e.constructor===Sk.builtin.float_?(i=i.nb$float().nb$multiply(e),new Sk.misceval.Break("float")):(i=Sk.abstr.numberBinOp(i,e,"Mult"),new Sk.misceval.Break("slow"));i=i.nb$multiply(e)}):i.constructor===Sk.builtin.float_?"float":"slow",Sk.misceval.chain(r,e=>"float"===e?Sk.misceval.iterFor(n,e=>{if(e.constructor!==Sk.builtin.float_&&e.constructor!==Sk.builtin.int_)return i=Sk.abstr.numberBinOp(i,e,"Mult"),new Sk.misceval.Break("slow");i=i.nb$multiply(e)}):e,e=>{if("slow"===e)return Sk.misceval.iterFor(n,e=>{i=Sk.abstr.numberBinOp(i,e,"Mult")})},()=>i)},$flags:{FastCall:!0},$textsig:"($module, iterable, /, *, start=1)",$doc:"Calculate the product of all the elements in the input iterable. The default start value for the product is 1.\n\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types."},pow:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if("number"!=typeof n&&(n=e.nb$float().v),"number"!=typeof i&&(i=t.nb$float().v),0==n&&i<0)throw new Sk.builtin.ValueError("math domain error");if(1==n)return new Sk.builtin.float_(1);if(Number.isFinite(n)&&Number.isFinite(i)&&n<0&&!Number.isInteger(i))throw new Sk.builtin.ValueError("math domain error");if(-1==n&&(i==-1/0||i==1/0))return new Sk.builtin.float_(1);if(e=Math.pow(n,i),Number.isFinite(n)&&Number.isFinite(i)&&(e==1/0||e==-1/0))throw new Sk.builtin.OverflowError("math range error");return new Sk.builtin.float_(e)},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return x**y (x to the power of y)."},radians:{$meth:function(e){return Sk.builtin.pyCheckType("deg","number",Sk.builtin.checkNumber(e)),e=Math.PI/180*Sk.builtin.asnum$(e),new Sk.builtin.float_(e)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Convert angle x from degrees to radians."},remainder:{$meth:function(e,t){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType("y","number",Sk.builtin.checkNumber(t));let u=e.v,l=t.v;if("number"!=typeof u&&(u=e.nb$float().v),"number"!=typeof l&&(l=t.nb$float().v),isFinite(u)&&isFinite(l)){let e,t,n,i,r;if(0==l)throw new Sk.builtin.ValueError("math domain error");if((i=(e=Math.abs(u))%(t=Math.abs(l)))<(n=t-i))r=i;else if(n<i)r=-n;else{if(i!=n)throw new Sk.builtin.AssertionError;r=i-.5*(e-i)%t*2}return new Sk.builtin.float_(m(u)*r)}if(isNaN(u))return e;if(isNaN(l))return t;if(u==1/0||u==-1/0)throw new Sk.builtin.ValueError("math domain error");if(l!=1/0&&l!=-1/0)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(u)},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Difference between x and the closest integer multiple of y.\n\nReturn x - n*y where n*y is the closest integer multiple of y.\nIn the case where x is exactly halfway between two multiples of\ny, the nearest even value of n is used. The result is always exact."},sin:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the sine of x (measured in radians)."},sinh:{$meth:function(e){Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);var t=Math.E,t=Math.pow(t,e);return new Sk.builtin.float_((t-1/t)/2)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the hyperbolic sine of x."},sqrt:{$meth:function(e){if(Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),(e=Sk.builtin.asnum$(e))<0)throw new Sk.builtin.ValueError("math domain error");return new Sk.builtin.float_(Math.sqrt(e))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the square root of x."},tan:{$meth:function(e){return Sk.builtin.pyCheckType("rad","number",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the tangent of x (measured in radians)."},tanh:{$meth:function(e){var t;return Sk.builtin.pyCheckType("x","number",Sk.builtin.checkNumber(e)),0===(e=Sk.builtin.asnum$(e))?new Sk.builtin.float_(e):(t=Math.E,e=1/(t=Math.pow(t,e)),new Sk.builtin.float_((t-e)/2/((t+e)/2)))},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the hyperbolic tangent of x."},trunc:{$meth:function(e){if(e.ob$type===r)return e.nb$int();var t=o(e,n.$trunc);if(void 0===t)throw new u(`type ${e.tp$name} doesn't define __trunc__ method`);return s(t)},$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Truncates the Real x to the nearest Integral toward 0.\n\nUses the __trunc__ magic method."}}),t};