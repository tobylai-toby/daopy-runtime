var $builtinmodule=function(t){var n={};function i(t,e,i){[e,i]=Sk.abstr.copyKeywordsToNamedArgs(t.tp$name,["iterable","r"],e,i,[]);var r,e=Sk.misceval.arrayFromIterable(e),i=Sk.misceval.asIndexSized(i,Sk.builtin.OverFlowError);if(i<0)throw new Sk.builtin.ValueError("r must be non-negative");return this===t?new t.constructor(e,i):(r=new this.constructor,t.constructor.call(r,e,i),r)}return n.accumulate=Sk.abstr.buildIteratorClass("itertools.accumulate",{constructor:function(t,e,i){this.iter=t,this.func=e,this.total=i,this.tp$iternext=()=>(this.total=Sk.builtin.checkNone(this.total)?this.iter.tp$iternext():this.total,this.tp$iternext=this.constructor.prototype.tp$iternext,this.total)},iternext(t){var e=this.iter.tp$iternext();if(void 0!==e)return this.total=Sk.misceval.callsimArray(this.func,[this.total,e]),this.total},slots:{tp$doc:"accumulate(iterable[, func, initial]) --\x3e accumulate object\n\nReturn series of accumulated sums (or other binary function results).",tp$new(t,e){Sk.abstr.checkArgsLen("accumulate",t,0,2);var i,[t,e,r]=Sk.abstr.copyKeywordsToNamedArgs("accumulate",["iterable","func","initial"],t,e,[Sk.builtin.none.none$,Sk.builtin.none.none$]),t=Sk.abstr.iter(t),e=Sk.builtin.checkNone(e)?new Sk.builtin.func((t,e)=>Sk.abstr.numberBinOp(t,e,"Add")):e;return this===n.accumulate.prototype?new n.accumulate(t,e,r):(i=new this.constructor,n.accumulate.call(i,t,e,r),i)}}}),n.chain=Sk.abstr.buildIteratorClass("itertools.chain",{constructor:function(t){this.iterables=t,this.current_it=null,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,this.current_it=this.iterables.tp$iternext(),void 0!==this.current_it)return this.current_it=Sk.abstr.iter(this.current_it),this.tp$iternext();this.tp$iternext=()=>{}}},iternext(t){let e;for(;void 0===e;){if(void 0!==(e=this.current_it.tp$iternext()))return e;if(this.current_it=this.iterables.tp$iternext(),void 0===this.current_it)return void(this.tp$iternext=()=>{});this.current_it=Sk.abstr.iter(this.current_it)}},slots:{tp$doc:"chain(*iterables) --\x3e chain object\n\nReturn a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.",tp$new(t,e){return Sk.abstr.checkNoKwargs("chain",e),t=new Sk.builtin.tuple(t.slice(0)).tp$iter(),this===n.chain.prototype?new n.chain(t):(e=new this.constructor,n.chain.call(e,t),e)}},classmethods:Object.assign({from_iterable:{$meth(t){t=Sk.abstr.iter(t);return new n.chain(t)},$flags:{OneArg:!0},$doc:"chain.from_iterable(iterable) --\x3e chain object\n\nAlternate chain() constructor taking a single iterable argument\nthat evaluates lazily.",$textsig:null}},Sk.generic.classGetItem)}),n.combinations=Sk.abstr.buildIteratorClass("itertools.combinations",{constructor:function(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill().map((t,e)=>e),this.n=t.length,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){let e,i=!1;for(e=this.r-1;0<=e;e--)if(this.indices[e]!=e+this.n-this.r){i=!0;break}if(i){this.indices[e]++;for(let t=e+1;t<this.r;t++)this.indices[t]=this.indices[t-1]+1;var r=this.indices.map(t=>this.pool[t]);return new Sk.builtin.tuple(r)}this.r=0},slots:{tp$doc:"combinations(iterable, r) --\x3e combinations object\n\nReturn successive r-length combinations of elements in the iterable.\n\ncombinations(range(4), 3) --\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)",tp$new(t,e){return i.call(this,n.combinations.prototype,t,e)}}}),n.combinations_with_replacement=Sk.abstr.buildIteratorClass("itertools.combinations_with_replacement",{constructor:function(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill(0),this.n=t.length,this.tp$iternext=()=>{var t;if(!this.r||this.n)return this.tp$iternext=this.constructor.prototype.tp$iternext,t=this.indices.map(t=>this.pool[t]),new Sk.builtin.tuple(t)}},iternext(t){let e=!1,i;for(i=this.r-1;0<=i;i--)if(this.indices[i]!=this.n-1){e=!0;break}if(e){var r=this.indices[i]+1;for(let t=i;t<this.r;t++)this.indices[t]=r;var s=this.indices.map(t=>this.pool[t]);return new Sk.builtin.tuple(s)}this.r=0},slots:{tp$doc:"combinations_with_replacement(iterable, r) --\x3e combinations_with_replacement object\n\nReturn successive r-length combinations of elements in the iterable\nallowing individual elements to have successive repeats.\ncombinations_with_replacement('ABC', 2) --\x3e AA AB AC BB BC CC",tp$new(t,e){return i.call(this,n.combinations_with_replacement.prototype,t,e)}}}),n.compress=Sk.abstr.buildIteratorClass("itertools.compress",{constructor:function(t,e){this.data=t,this.selectors=e},iternext(){let t=this.data.tp$iternext(),e=this.selectors.tp$iternext();for(;void 0!==t&&void 0!==e;){if(Sk.misceval.isTrue(e))return t;t=this.data.tp$iternext(),e=this.selectors.tp$iternext()}},slots:{tp$doc:"compress(data, selectors) --\x3e iterator over selected data\n\nReturn data elements corresponding to true selector elements.\nForms a shorter iterator from selected data elements using the\nselectors to choose the data elements.",tp$new(t,e){var i;return[t,e]=Sk.abstr.copyKeywordsToNamedArgs("compress",["data","selectors"],t,e,[]),t=Sk.abstr.iter(t),e=Sk.abstr.iter(e),this===n.count.prototype?new n.compress(t,e):(i=new this.constructor,n.compress.call(i,t,e),i)}}}),n.count=Sk.abstr.buildIteratorClass("itertools.count",{constructor:function(t,e){this.start=t,this.step=e},iternext(){var t=this.start;return this.start=Sk.abstr.numberBinOp(this.start,this.step,"Add"),t},slots:{tp$doc:"count(start=0, step=1) --\x3e count object\n\nReturn a count object whose .__next__() method returns consecutive values.\nEquivalent to:\n\n    def count(firstval=0, step=1):\n        x = firstval\n        while 1:\n            yield x\n            x += step\n",tp$new(t,e){var i,[t,e]=Sk.abstr.copyKeywordsToNamedArgs("count",["start","step"],t,e,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]);if((Sk.builtin.checkNumber(t)||Sk.builtin.checkComplex(t))&&(Sk.builtin.checkNumber(e)||Sk.builtin.checkComplex(e)))return this===n.count.prototype?new n.count(t,e):(i=new this.constructor,n.count.call(i,t,e),i);throw new Sk.builtin.TypeError("a number is required")},$r(){var t=Sk.misceval.objectRepr(this.start),e="1"===(e=Sk.misceval.objectRepr(this.step))?"":", "+e;return new Sk.builtin.str(Sk.abstr.typeName(this)+"("+t+e+")")}}}),n.cycle=Sk.abstr.buildIteratorClass("itertools.cycle",{constructor:function(t){this.iter=t,this.saved=[],this.consumed=!1,this.i=0,this.length},iternext(){let t;if(!this.consumed){if(void 0!==(t=this.iter.tp$iternext()))return this.saved.push(t),t;if(this.consumed=!0,this.length=this.saved.length,!this.length)return}return t=this.saved[this.i],this.i=(this.i+1)%this.length,t},slots:{tp$doc:"cycle(iterable) --\x3e cycle object\n\nReturn elements from the iterable until it is exhausted.\nThen repeat the sequence indefinitely.",tp$new(t,e){Sk.abstr.checkOneArg("cycle",t,e);e=Sk.abstr.iter(t[0]);return this===n.cycle.prototype?new n.cycle(e):(t=new this.constructor,n.cycle.call(t,e),t)}}}),n.dropwhile=Sk.abstr.buildIteratorClass("itertools.dropwhile",{constructor:function(t,e){this.predicate=t,this.iter=e,this.passed},iternext(){let t=this.iter.tp$iternext();for(;void 0===this.passed&&void 0!==t;){var e=Sk.misceval.callsimArray(this.predicate,[t]);if(!Sk.misceval.isTrue(e))return this.passed=!0,t;t=this.iter.tp$iternext()}return t},slots:{tp$doc:"dropwhile(predicate, iterable) --\x3e dropwhile object\n\nDrop items from the iterable while predicate(item) is true.\nAfterwards, return every element until the iterable is exhausted.",tp$new(t,e){Sk.abstr.checkNoKwargs("dropwhile",e),Sk.abstr.checkArgsLen("dropwhile",t,2,2);var i,e=t[0],t=Sk.abstr.iter(t[1]);return this===n.dropwhile.prototype?new n.dropwhile(e,t):(i=new this.constructor,n.dropwhile.call(i,e,t),i)}}}),n.filterfalse=Sk.abstr.buildIteratorClass("itertools.filterfalse",{constructor:function(t,e){this.predicate=t,this.iter=e},iternext(t){let e=this.iter.tp$iternext();if(void 0!==e){let t=Sk.misceval.callsimArray(this.predicate,[e]);for(;Sk.misceval.isTrue(t);){if(void 0===(e=this.iter.tp$iternext()))return;t=Sk.misceval.callsimArray(this.predicate,[e])}return e}},slots:{tp$doc:"filterfalse(function or None, sequence) --\x3e filterfalse object\n\nReturn those items of sequence for which function(item) is false.\nIf function is None, return the items that are false.",tp$new(t,e){Sk.abstr.checkNoKwargs("filterfalse",e),Sk.abstr.checkArgsLen("filterfalse",t,2,2);var i,e=Sk.builtin.checkNone(t[0])?Sk.builtin.bool:t[0],t=Sk.abstr.iter(t[1]);return this===n.filterfalse.prototype?new n.filterfalse(e,t):(i=new this.constructor,n.filterfalse.call(i,e,t),i)}}}),n._grouper=Sk.abstr.buildIteratorClass("itertools._grouper",{constructor:function(t,e){this.groupby=t,this.tgtkey=t.tgtkey,this.id=t.id},iternext(t){var e=Sk.misceval.richCompareBool(this.groupby.currkey,this.tgtkey,"Eq");if(this.groupby.id===this.id&&e)return e=this.groupby.currval,this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),e}}),n.groupby=Sk.abstr.buildIteratorClass("itertools.groupby",{constructor:function(t,e){this.iter=t,this.keyf=e,this.currval,this.currkey=this.tgtkey=new Sk.builtin.object,this.id},iternext(t){this.id=new Object;let e=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,"Eq");for(;e;){if(this.currval=this.iter.tp$iternext(),void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]),e=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,"Eq")}this.tgtkey=this.currkey;var i=new n._grouper(this);return new Sk.builtin.tuple([this.currkey,i])},slots:{tp$doc:"groupby(iterable, key=None) -> make an iterator that returns consecutive\nkeys and groups from the iterable.  If the key function is not specified or\nis None, the element itself is used for grouping.\n",tp$new(t,e){var i;return[t,e]=Sk.abstr.copyKeywordsToNamedArgs("groupby",["iterable","key"],t,e,[Sk.builtin.none.none$]),t=Sk.abstr.iter(t),e=Sk.builtin.checkNone(e)?new Sk.builtin.func(t=>t):e,this===n.groupby.prototype?new n.groupby(t,e):(i=new this.constructor,n.groupby.call(i,t,e),i)}}}),n.islice=Sk.abstr.buildIteratorClass("itertools.islice",{constructor:function(t,e,i,r){this.iter=t,this.previt=e,this.stop=i,this.step=r,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,!(this.previt>=this.stop)){for(let t=0;t<this.previt;t++)this.iter.tp$iternext();return this.iter.tp$iternext()}for(let t=0;t<this.stop;t++)this.iter.tp$iternext()}},iternext(t){if(!(this.previt+this.step>=this.stop)){for(let t=this.previt+1;t<this.previt+this.step;t++)this.iter.tp$iternext();return this.previt+=this.step,this.iter.tp$iternext()}for(let t=this.previt+1;t<this.stop;t++)this.previt+=this.step,this.iter.tp$iternext()},slots:{tp$doc:"islice(iterable, stop) --\x3e islice object\nislice(iterable, start, stop[, step]) --\x3e islice object\n\nReturn an iterator whose next() method returns selected values from an\niterable.  If start is specified, will skip all preceding elements;\notherwise, start defaults to zero.  Step defaults to one.  If\nspecified as another value, step determines how many values are \nskipped between successive calls.  Works like a slice() on a list\nbut returns an iterator.",tp$new(t,e){Sk.abstr.checkNoKwargs("islice",e),Sk.abstr.checkArgsLen("islice",t,2,4);e=Sk.abstr.iter(t[0]);let i=t[1],r=t[2],s=t[3];if(void 0===r?(r=i,i=Sk.builtin.none.none$,s=Sk.builtin.none.none$):void 0===s&&(s=Sk.builtin.none.none$),!Sk.builtin.checkNone(r)&&!Sk.misceval.isIndex(r))throw new Sk.builtin.ValueError("Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.");if((r=Sk.builtin.checkNone(r)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(r))<0||r>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError("Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.");if(!Sk.builtin.checkNone(i)&&!Sk.misceval.isIndex(i))throw new Sk.builtin.ValueError("Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.");if((i=Sk.builtin.checkNone(i)?0:Sk.misceval.asIndexSized(i))<0||i>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError("Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.");if(!Sk.builtin.checkNone(s)&&!Sk.misceval.isIndex(s))throw new Sk.builtin.ValueError("Step for islice() must be a positive integer or None");if((s=Sk.builtin.checkNone(s)?1:Sk.misceval.asIndexSized(s))<=0||s>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError("Step for islice() must be a positive integer or None.");return this===n.islice.prototype?new n.islice(e,i,r,s):(t=new this.constructor,n.islice.call(t,e,i,r,s),t)}}}),n.permutations=Sk.abstr.buildIteratorClass("itertools.permutations",{constructor:function(t,e){this.pool=t,this.r=e;const i=t.length;this.indices=new Array(i).fill().map((t,e)=>e),this.cycles=new Array(e).fill().map((t,e)=>i-e),this.n=i,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){for(let t=this.r-1;0<=t;t--){var e;if(this.cycles[t]--,0!=this.cycles[t])return e=this.cycles[t],[this.indices[t],this.indices[this.n-e]]=[this.indices[this.n-e],this.indices[t]],e=this.indices.map(t=>this.pool[t]).slice(0,this.r),new Sk.builtin.tuple(e);this.indices.push(this.indices.splice(t,1)[0]),this.cycles[t]=this.n-t}this.r=0},slots:{tp$doc:"permutations(iterable[, r]) --\x3e permutations object\n\nReturn successive r-length permutations of elements in the iterable.\n\npermutations(range(3), 2) --\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)",tp$new(t,e){[t,e]=Sk.abstr.copyKeywordsToNamedArgs("permutations",["iterable","r"],t,e,[Sk.builtin.none.none$]);var i,t=Sk.misceval.arrayFromIterable(t),e=Sk.builtin.checkNone(e)?t.length:Sk.misceval.asIndexSized(e,Sk.builtin.OverFlowError);if(e<0)throw new Sk.builtin.ValueError("r must be non-negative");return this===n.permutations.prototype?new n.permutations(t,e):(i=new this.constructor,n.permutations.call(i,t,e),i)}}}),n.product=Sk.abstr.buildIteratorClass("itertools.product",{constructor:function(t){this.pools=t,this.n=t.length,this.indices=Array(t.length).fill(0),this.pool_sizes=t.map(t=>t.length),this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;var t=this.indices.map((t,e)=>this.pools[e][this.indices[e]]);if(!t.some(t=>void 0===t))return new Sk.builtin.tuple(t);this.n=0}},iternext(t){let e=this.n-1;for(;0<=e&&e<this.n;)this.indices[e]++,this.indices[e]>=this.pool_sizes[e]?(this.indices[e]=-1,e--):e++;var i;if(this.n&&!this.indices.every(t=>-1===t))return i=this.indices.map((t,e)=>this.pools[e][this.indices[e]]),new Sk.builtin.tuple(i);this.n=0},slots:{tp$doc:"product(*iterables, repeat=1) --\x3e product object\n\nCartesian product of input iterables.  Equivalent to nested for-loops.\n\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\nThe leftmost iterators are in the outermost for-loop, so the output tuples\ncycle in a manner similar to an odometer (with the rightmost element changing\non every iteration).\n\nTo compute the product of an iterable with itself, specify the number\nof repetitions with the optional repeat keyword argument. For example,\nproduct(A, repeat=4) means the same as product(A, A, A, A).\n\nproduct('ab', range(3)) --\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\nproduct((0,1), (0,1), (0,1)) --\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...",tp$new(e,t){var[t]=Sk.abstr.copyKeywordsToNamedArgs("product",["repeat"],[],t,[new Sk.builtin.int_(1)]);if((t=Sk.misceval.asIndexSized(t,Sk.builtin.OverFlowError))<0)throw new Sk.builtin.ValueError("repeat argument cannot be negative");var i=[];for(let t=0;t<e.length;t++)i.push(Sk.misceval.arrayFromIterable(e[t]));var r,t=[].concat(...Array(t).fill(i));return this===n.product.prototype?new n.product(t):(r=new this.constructor,n.product.call(r,t),r)}}}),n.repeat=Sk.abstr.buildIteratorClass("itertools.repeat",{constructor:function(t,e){this.object=t,void 0===(this.times=e)&&(this.tp$iternext=()=>this.object)},iternext(t){return 0<this.times--?this.object:void 0},slots:{tp$doc:"repeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.",tp$new(t,e){let i,r;return[i,r]=Sk.abstr.copyKeywordsToNamedArgs("repeat",["object","times"],t,e,[null]),r=null!==r?Sk.misceval.asIndexSized(r,Sk.builtin.OverFlowError):void 0,this===n.repeat.prototype?new n.repeat(i,r):(t=new this.constructor,n.repeat.call(t,i,r),t)},$r(){var t=Sk.misceval.objectRepr(this.object),e=void 0===this.times?"":", "+(0<=this.times?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+"("+t+e+")")}},methods:{__lenght_hint__:{$meth(){if(void 0===this.times)throw new Sk.builtin.TypeError("len() of unsized object");return new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}}),n.starmap=Sk.abstr.buildIteratorClass("itertools.starmap",{constructor:function(t,e){this.func=t,this.iter=e},iternext(t){var e=this.iter.tp$iternext();if(void 0!==e)return e=Sk.misceval.arrayFromIterable(e),Sk.misceval.callsimArray(this.func,e)},slots:{tp$new(t,e){var i;return[t,e]=Sk.abstr.copyKeywordsToNamedArgs("starmap",["func","iterable"],t,e,[]),e=Sk.abstr.iter(e),t=Sk.builtin.checkNone(t)?Sk.builtin.bool:t,this===n.starmap.prototype?new n.starmap(t,e):(i=new this.constructor,n.starmap.call(i,t,e),i)}}}),n.takewhile=Sk.abstr.buildIteratorClass("itertools.takewhile",{constructor:function(t,e){this.predicate=t,this.iter=e},iternext(){var t=this.iter.tp$iternext();if(void 0!==t){var e=Sk.misceval.callsimArray(this.predicate,[t]);if(Sk.misceval.isTrue(e))return t;this.tp$iternext=()=>{}}},slots:{tp$doc:"takewhile(predicate, iterable) --\x3e takewhile object\n\nReturn successive entries from an iterable as long as the \npredicate evaluates to true for each entry.",tp$new(t,e){Sk.abstr.checkNoKwargs("takewhile",e),Sk.abstr.checkArgsLen("takewhile",t,2,2);var i,e=t[0],t=Sk.abstr.iter(t[1]);return this===n.takewhile.prototype?new n.takewhile(e,t):(i=new this.constructor,n.takewhile.call(i,e,t),i)}}}),n.tee=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError("tee is not yet implemented in Skulpt")}),n.zip_longest=Sk.abstr.buildIteratorClass("itertools.zip_longest",{constructor:function(t,e){this.iters=t,this.fillvalue=e,this.active=this.iters.length},iternext(t){if(this.active){let e;var i=[];for(let t=0;t<this.iters.length;t++){if(void 0===(e=this.iters[t].tp$iternext())){if(this.active--,!this.active)return;this.iters[t]=new n.repeat(this.fillvalue),e=this.fillvalue}i.push(e)}return new Sk.builtin.tuple(i)}},slots:{tp$doc:"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\x3e zip_longest object\n\nReturn a zip_longest object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the longest iterable in the argument sequence\nis exhausted and then it raises StopIteration.  When the shorter iterables\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\ndefaults to None or can be specified by a keyword argument.\n",tp$new(e,t){var i,[t]=Sk.abstr.copyKeywordsToNamedArgs("zip_longest",["fillvalue"],[],t,[Sk.builtin.none.none$]),r=[];for(let t=0;t<e.length;t++)r.push(Sk.abstr.iter(e[t]));return this===n.zip_longest.prototype?new n.zip_longest(r,t):(i=new this.constructor,n.zip_longest.call(i,r,t),i)}}}),n.__doc__=new Sk.builtin.str("An implementation of the python itertools module in Skulpt"),n.__package__=new Sk.builtin.str(""),n};