function $builtinmodule(t){const e={};return Sk.misceval.chain(Sk.importModule("keyword",!1,!0),t=>(e._iskeyword=t.$d.iskeyword,Sk.importModule("itertools",!1,!0)),t=>(e._chain=t.$d.chain,e._starmap=t.$d.starmap,e._repeat=t.$d.repeat,Sk.importModule("operator",!1,!0)),t=>{e._itemgetter=t.$d.itemgetter},()=>collections_mod(e))}function collections_mod($){function t(i){return function(t){var e;return void 0===t||t instanceof $.Counter?(e=new $.Counter,i.call(this,e,t),e):Sk.builtin.NotImplemented.NotImplemented$}}function e(e,i){return function(t){if(t instanceof Sk.builtin.dict)return i.call(this,t),this.keep$positive();throw new Sk.builtin.TypeError("Counter "+e+"= "+Sk.abstr.typeName(t)+" is not supported")}}$.__all__=new Sk.builtin.list(["deque","defaultdict","namedtuple","Counter","OrderedDict"].map(t=>new Sk.builtin.str(t))),$.defaultdict=Sk.abstr.buildNativeClass("collections.defaultdict",{constructor:function(t,e){this.default_factory=t,Sk.builtin.dict.call(this,e)},base:Sk.builtin.dict,methods:{copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth(t){var e;if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(t));return e=Sk.misceval.callsimArray(this.default_factory,[]),this.mp$ass_subscript(t,e),e},$flags:{OneArg:!0}}},getsets:{default_factory:{$get(){return this.default_factory},$set(t){t=t||Sk.builtin.none.none$,this.default_factory=t}}},slots:{tp$doc:"",tp$init(t,e){var i=t.shift();if(void 0===i)this.default_factory=Sk.builtin.none.none$;else{if(!Sk.builtin.checkCallable(i)&&!Sk.builtin.checkNone(i))throw new Sk.builtin.TypeError("first argument must be callable");this.default_factory=i}return Sk.builtin.dict.prototype.tp$init.call(this,t,e)},$r(){var t=Sk.misceval.objectRepr(this.default_factory),e=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str("defaultdict("+t+", "+e+")")}},proto:{$copy(){const e=[];return Sk.misceval.iterFor(Sk.abstr.iter(this),t=>{e.push(t),e.push(this.mp$subscript(t))}),new $.defaultdict(this.default_factory,e)}}}),$.Counter=Sk.abstr.buildNativeClass("Counter",{constructor:function(){this.$d=new Sk.builtin.dict,Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth(){var t=$._chain.tp$getattr(new Sk.builtin.str("from_iterable")),e=$._starmap,i=$._repeat,s=Sk.misceval.callsimArray;return s(t,[s(e,[i,s(this.tp$getattr(this.str$items))])])}},most_common:{$flags:{NamedArgs:["n"],Defaults:[Sk.builtin.none.none$]},$meth(t){var e=this.sq$length(),e=(t=Sk.builtin.checkNone(t)||e<(t=Sk.misceval.asIndexOrThrow(t))?e:t<0?0:t,this.$items().sort((t,e)=>Sk.misceval.richCompareBool(t[1],e[1],"Lt")?1:Sk.misceval.richCompareBool(t[1],e[1],"Gt")?-1:0));return new Sk.builtin.list(e.slice(0,t).map(t=>new Sk.builtin.tuple(t)))}},update:{$flags:{FastCall:!0},$meth(t,e){return Sk.abstr.checkArgsLen("update",t,0,1),this.counter$update(t,e)}},subtract:{$flags:{FastCall:!0},$meth(t,e){Sk.abstr.checkArgsLen("subtract",t,0,1);var i=t[0];if(void 0!==i)if(i instanceof Sk.builtin.dict)for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext()){var s=this.mp$subscript(e);this.mp$ass_subscript(e,Sk.abstr.numberBinOp(s,i.mp$subscript(e),"Sub"))}else for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext()){var r=this.mp$subscript(e);this.mp$ass_subscript(e,Sk.abstr.numberBinOp(r,this.$one,"Sub"))}e=e||[];for(let t=0;t<e.length;t+=2){var n=new Sk.builtin.str(e[t]),a=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(a,e[t+1],"Sub"))}return Sk.builtin.none.none$}},__missing__:{$meth(t){return this.$zero},$flags:{OneArg:!0}},copy:{$meth(){return Sk.misceval.callsimArray($.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:"Dict subclass for counting hashable items.  Sometimes called a bag\n    or multiset.  Elements are stored as dictionary keys and their counts\n    are stored as dictionary values.\n\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n    >>> c.most_common(3)                # three most common elements\n    [('a', 5), ('b', 4), ('c', 3)]\n    >>> sorted(c)                       # list all unique elements\n    ['a', 'b', 'c', 'd', 'e']\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\n    'aaaaabbbbcccdde'\n    >>> sum(c.values())                 # total of all counts\n    15\n\n    >>> c['a']                          # count of letter 'a'\n    5\n    >>> for elem in 'shazam':           # update counts from an iterable\n    ...     c[elem] += 1                # by adding 1 to each element's count\n    >>> c['a']                          # now there are seven 'a'\n    7\n    >>> del c['b']                      # remove all 'b'\n    >>> c['b']                          # now there are zero 'b'\n    0\n\n    >>> d = Counter('simsalabim')       # make another counter\n    >>> c.update(d)                     # add in the second counter\n    >>> c['a']                          # now there are nine 'a'\n    9\n\n    >>> c.clear()                       # empty the counter\n    >>> c\n    Counter()\n\n    Note:  If a count is set to zero or reduced to zero, it will remain\n    in the counter until the entry is deleted or the counter is cleared:\n\n    >>> c = Counter('aaabbc')\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\n    [('a', 3), ('c', 1), ('b', 0)]\n\n",tp$init(t,e){return Sk.abstr.checkArgsLen(this.tpjs_name,t,0,1),this.counter$update(t,e)},$r(){var t=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:"";return new Sk.builtin.str(Sk.abstr.typeName(this)+"("+t+")")},tp$as_sequence_or_mapping:!0,mp$ass_subscript(t,e){return(void 0!==e||this.mp$lookup(t))&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,t,e)},tp$as_number:!0,nb$positive:t(function(i){this.$items().forEach(([t,e])=>{Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&i.mp$ass_subscript(t,e)})}),nb$negative:t(function(i){this.$items().forEach(([t,e])=>{Sk.misceval.richCompareBool(e,this.$zero,"Lt")&&i.mp$ass_subscript(t,Sk.abstr.numberBinOp(this.$zero,e,"Sub"))})}),nb$subtract:t(function(i,s){this.$items().forEach(([t,e])=>{e=Sk.abstr.numberBinOp(e,s.mp$subscript(t),"Sub");Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&i.mp$ass_subscript(t,e)}),s.$items().forEach(([t,e])=>{void 0===this.mp$lookup(t)&&Sk.misceval.richCompareBool(e,this.$zero,"Lt")&&i.mp$ass_subscript(t,Sk.abstr.numberBinOp(this.$zero,e,"Sub"))})}),nb$add:t(function(i,s){this.$items().forEach(([t,e])=>{e=Sk.abstr.numberBinOp(e,s.mp$subscript(t),"Add");Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&i.mp$ass_subscript(t,e)}),s.$items().forEach(([t,e])=>{void 0===this.mp$lookup(t)&&Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&i.mp$ass_subscript(t,e)})}),nb$inplace_add:e("+",function(t){t.$items().forEach(([t,e])=>{e=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,"Add");this.mp$ass_subscript(t,e)})}),nb$inplace_subtract:e("-",function(t){t.$items().forEach(([t,e])=>{e=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,"Sub");this.mp$ass_subscript(t,e)})}),nb$or:t(function(s,r){this.$items().forEach(([t,e])=>{var i=r.mp$subscript(t),i=Sk.misceval.richCompareBool(e,i,"Lt")?i:e;Sk.misceval.richCompareBool(i,this.$zero,"Gt")&&s.mp$ass_subscript(t,i)}),r.$items().forEach(([t,e])=>{void 0===this.mp$lookup(t)&&Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&s.mp$ass_subscript(t,e)})}),nb$and:t(function(s,r){this.$items().forEach(([t,e])=>{var i=r.mp$subscript(t),e=Sk.misceval.richCompareBool(e,i,"Lt")?e:i;Sk.misceval.richCompareBool(e,this.$zero,"Gt")&&s.mp$ass_subscript(t,e)})}),nb$inplace_and:e("&",function(s){this.$items().forEach(([t,e])=>{var i=s.mp$subscript(t);Sk.misceval.richCompareBool(i,e,"Lt")&&this.mp$ass_subscript(t,i)})}),nb$inplace_or:e("|",function(t){t.$items().forEach(([t,e])=>{Sk.misceval.richCompareBool(e,this.mp$subscript(t),"Gt")&&this.mp$ass_subscript(t,e)})}),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},proto:{keep$positive(){return this.$items().forEach(([t,e])=>{Sk.misceval.richCompareBool(e,this.$zero,"LtE")&&this.mp$ass_subscript(t)}),this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str("items"),counter$update(t,e){var i=t[0];if(void 0!==i)if(Sk.builtin.checkMapping(i))if(this.sq$length())for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext()){var s=this.mp$subscript(e);this.mp$ass_subscript(e,Sk.abstr.numberBinOp(s,i.mp$subscript(e),"Add"))}else this.update$common(t,void 0,"update");else for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext()){var r=this.mp$subscript(e);this.mp$ass_subscript(e,Sk.abstr.numberBinOp(r,this.$one,"Add"))}if(e&&e.length)if(this.sq$length())for(let t=0;t<e.length;t+=2){var n=new Sk.builtin.str(e[t]),a=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(a,e[t+1],"Add"))}else this.update$common([],e,"update");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function(){throw new Sk.builtin.NotImplementedError("Counter.fromkeys() is undefined.  Use Counter(iterable) instead.")},$flags:{MinArgs:1,MaxArgs:2}}}}),$.OrderedDict=Sk.abstr.buildNativeClass("collections.OrderedDict",{constructor:function(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:"Dictionary that remembers insertion order",$r(){if(this.in$repr)return new Sk.builtin.str("...");this.in$repr=!0;let t=this.$items().map(([t,e])=>`(${Sk.misceval.objectRepr(t)}, ${Sk.misceval.objectRepr(e)})`);return t=0===t.length?"":"["+t.join(", ")+"]",this.in$repr=!1,new Sk.builtin.str(Sk.abstr.typeName(this)+"("+t+")")},tp$richcompare(t,e){if("Eq"!==e&&"Ne"!==e)return Sk.builtin.NotImplemented.NotImplemented$;if(!(t instanceof $.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,t,e);var i="Eq"==e,s=this.size;if(s!==t.size)return!i;var r=t.$items(),n=this.$items();for(let t=0;t<s;t++){var a=n[t],l=r[t],o=a[0],h=l[0];if(o!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(o,h,"Eq")))return!i;o=a[1],h=l[1];if(o!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(o,h,"Eq")))return!i}return i}},methods:{popitem:{$flags:{NamedArgs:["last"],Defaults:[Sk.builtin.bool.true$]},$meth(t){var e=this.get$size();if(0===e)throw new Sk.builtin.KeyError("dictionary is empty");var[t,e]=this.$items()[Sk.misceval.isTrue(t)?e-1:0];return this.pop$item(t),new Sk.builtin.tuple([t,e])}},move_to_end:{$flags:{NamedArgs:["key","last"],Defaults:[Sk.builtin.bool.true$]},$meth(t,e){let i;for(var s in this.entries){var r=this.entries[s][0];if(r===t||Sk.misceval.richCompareBool(r,t,"Eq")){i=s;break}}if(void 0===i)throw new Sk.builtin.KeyError(t);var n=this.entries[i];return delete this.entries[i],Sk.misceval.isTrue(e)?this.entries[i]=n:this.entries={[i]:n,...this.entries},Sk.builtin.none.none$}}}}),$.deque=Sk.abstr.buildNativeClass("collections.deque",{constructor:function(t,e,i,s,r){this.head=i||0,this.tail=s||0,this.mask=r||1,this.maxlen=e,this.v=t||new Array(2)},slots:{tp$doc:"deque([iterable[, maxlen]]) --\x3e deque object\n\nA list-like sequence optimized for data accesses near its endpoints.",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init(t,e){var[t,e]=Sk.abstr.copyKeywordsToNamedArgs("deque",["iterable","maxlen"],t,e);if(void 0!==e&&!Sk.builtin.checkNone(e)){if((e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError,"an integer is required"))<0)throw new Sk.builtin.ValueError("maxlen must be non-negative");this.maxlen=e}this.$clear(),void 0!==t&&this.$extend(t)},tp$getattr:Sk.generic.getAttr,tp$richcompare(t,e){if(this===t&&Sk.misceval.opAllowsEquality(e))return!0;if(!(t instanceof $.deque))return Sk.builtin.NotImplemented.NotImplemented$;var i=t,s=this.v,r=(t=t.v,this.tail-this.head&this.mask),n=i.tail-i.head&i.mask;let a=Math.max(r,n);if(r==n)for(a=0;a<r&&a<n&&Sk.misceval.richCompareBool(s[this.head+a&this.mask],t[i.head+a&i.mask],"Eq");++a);if(a>=r||a>=n)switch(e){case"Lt":return r<n;case"LtE":return r<=n;case"Eq":return r==n;case"NotEq":return r!=n;case"Gt":return n<r;case"GtE":return n<=r}return"Eq"!==e&&("NotEq"===e||Sk.misceval.richCompareBool(s[this.head+a&this.mask],t[i.head+a&i.mask],e))},tp$iter(){return new i(this)},$r(){var e=[],i=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str("[...]");this.$entered_repr=!0;for(let t=0;t<i;t++)e.push(Sk.misceval.objectRepr(this.v[this.head+t&this.mask]));var t=Sk.abstr.typeName(this);return void 0!==this.maxlen?new Sk.builtin.str(t+"(["+e.filter(Boolean).join(", ")+"], maxlen="+this.maxlen+")"):(this.$entered_repr=void 0,new Sk.builtin.str(t+"(["+e.filter(Boolean).join(", ")+"])"))},tp$as_number:!0,nb$bool(){return 0!=(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains(i){for(let t=this.tp$iter(),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())if(Sk.misceval.richCompareBool(e,i,"Eq"))return!0;return!1},sq$concat(i){if(!(i instanceof $.deque))throw new Sk.builtin.TypeError("can only concatenate deque (not '"+Sk.abstr.typeName(i)+"') to deque");var s=this.$copy();for(let t=i.tp$iter(),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())s.$push(e);return s},sq$length(){return this.tail-this.head&this.mask},sq$repeat(e){e=Sk.misceval.asIndexOrThrow(e,"can't multiply sequence by non-int of type '{tp$name}'");var i,s=this.tail-this.head&this.mask,r=this.$copy();e<=0&&r.$clear();for(let t=1;t<e;t++)for(let t=0;t<s;t++)i=this.head+t&this.mask,r.$push(this.v[i]);return r},mp$subscript(t){t=Sk.misceval.asIndexOrThrow(t);var e=this.tail-this.head&this.mask;if(e<=t||t<-e)throw new Sk.builtin.IndexError("deque index out of range");e=(0<=t?this.head:this.tail)+t&this.mask;return this.v[e]},mp$ass_subscript(t,e){t=Sk.misceval.asIndexOrThrow(t);var i=this.tail-this.head&this.mask;if(i<=t||t<-i)throw new Sk.builtin.IndexError("deque index out of range");void 0===e?this.del$item(t):this.set$item(t,e)},nb$inplace_add(i){this.maxlen=void 0;for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())this.$push(e);return this},nb$inplace_multiply(e){(e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError,"can't multiply sequence by non-int of type '{tp$name}'"))<=0&&this.$clear();var i=this.$copy(),s=this.tail-this.head&this.mask;for(let t=1;t<e;t++)for(let t=0;t<s;t++){var r=this.head+t&this.mask;i.$push(this.v[r])}return this.v=i.v,this.head=i.head,this.tail=i.tail,this.mask=i.mask,this}},methods:{append:{$meth(t){return this.$push(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Add an element to the right side of the deque."},appendleft:{$meth(t){return this.$pushLeft(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Add an element to the left side of the deque."},clear:{$meth(){return this.$clear(),Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove all elements from the deque."},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a shallow copy of a deque."},copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a shallow copy of a deque."},count:{$meth(e){var i=this.tail-this.head&this.mask;let s=0;for(let t=0;t<i;t++)Sk.misceval.richCompareBool(this.v[this.head+t&this.mask],e,"Eq")&&s++;return new Sk.builtin.int_(s)},$flags:{OneArg:!0},$textsig:null,$doc:"D.count(value) -> integer -- return number of occurrences of value"},extend:{$meth(t){return this.$extend(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Extend the right side of the deque with elements from the iterable"},extendleft:{$meth(i){for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())this.$pushLeft(e);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Extend the left side of the deque with elements from the iterable"},index:{$meth(t,e,i){e=this.$index(t,e,i);if(void 0!==e)return new Sk.builtin.int_(e);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+" is not in deque")},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"D.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present."},insert:{$meth(t,e){t=Sk.misceval.asIndexOrThrow(t,"integer argument expected, got {tp$name}");var i=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&i>=this.maxlen)throw new Sk.builtin.IndexError("deque already at its maximum size");var s=(0<=(t=(t=i<t?i:t)<=-i?0:t)?this.head:this.tail)+t&this.mask;let r=this.tail;for(this.tail=this.tail+1&this.mask;r!==s;){var n=r-1&this.mask;this.v[r]=this.v[n],r=n}return this.v[s]=e,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1),Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:"D.insert(index, object) -- insert object before index"},pop:{$meth(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove and return the rightmost element."},popleft:{$meth(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove and return the leftmost element."},remove:{$meth(t){var e=this.$index(t);if(void 0===e)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+" is not in deque");let i=this.head+e&this.mask;for(;i!==this.tail;){var s=i+1&this.mask;this.v[i]=this.v[s],i=s}this.tail=this.tail-1&this.mask;t=this.tail-this.head&this.mask;t<this.mask>>>1&&this.$resize(t,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:"D.remove(value) -- remove first occurrence of value."},__reversed__:{$meth(){return new s(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.__reversed__() -- return a reverse iterator over the deque"},reverse:{$meth(){var e=this.head,i=this.tail,s=this.mask,r=this.tail-this.head&this.mask;for(let t=0;t<~~(r/2);t++){var n=i-t-1&s,a=e+t&s,l=this.v[n];this.v[n]=this.v[a],this.v[a]=l}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:"D.reverse() -- reverse *IN PLACE*"},rotate:{$meth(e){e=void 0===e?1:Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);var i=this.head,s=this.tail;if(0===e||i===s)return this;if(this.head=i-e&this.mask,this.tail=s-e&this.mask,0<e)for(let t=1;t<=e;t++){var r=i-t&this.mask,n=s-t&this.mask;this.v[r]=this.v[n],this.v[n]=void 0}else for(let t=0;t>e;t--){var a=s-t&this.mask,l=i-t&this.mask;this.v[a]=this.v[l],this.v[l]=void 0}return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left."}},classmethods:Sk.generic.classGetItem,getsets:{maxlen:{$get(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:"maximum size of a deque or None if unbounded"}},proto:{$clear(){this.head=0,this.tail=0,this.mask=1,this.v=new Array(2)},$copy(){return new $.deque(this.v.slice(0),this.maxlen,this.head,this.tail,this.mask)},$extend(i){for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())this.$push(e)},set$item(t,e){t=(0<=t?this.head:this.tail)+t&this.mask;this.v[t]=e},del$item(t){let e=(0<=t?this.head:this.tail)+t&this.mask;for(;e!==this.tail;){var i=e+1&this.mask;this.v[e]=this.v[i],e=i}t=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask,t<this.mask>>>1&&this.$resize(t,this.v.length>>>1)},$push(t){this.v[this.tail]=t,this.tail=this.tail+1&this.mask,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);t=this.tail-this.head&this.mask;return void 0!==this.maxlen&&t>this.maxlen&&this.$popLeft(),this},$pushLeft(t){this.head=this.head-1&this.mask,this.v[this.head]=t,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);t=this.tail-this.head&this.mask;return void 0!==this.maxlen&&t>this.maxlen&&this.$pop(),this},$pop(){if(this.head===this.tail)throw new Sk.builtin.IndexError("pop from an empty deque");this.tail=this.tail-1&this.mask;var t=this.v[this.tail],e=(this.v[this.tail]=void 0,this.tail-this.head&this.mask);return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$popLeft(){if(this.head===this.tail)throw new Sk.builtin.IndexError("pop from an empty deque");var t=this.v[this.head],e=(this.v[this.head]=void 0,this.head=this.head+1&this.mask,this.tail-this.head&this.mask);return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$resize(e,t){var i=this.head,s=this.mask;if(this.head=0,this.tail=e,this.mask=t-1,0===i)this.v.length=t;else{var r=new Array(t);for(let t=0;t<e;t++)r[t]=this.v[i+t&s];this.v=r}},$index(e,i,s){var r=this.tail-this.head&this.mask,n=(i=void 0===i?0:Sk.misceval.asIndexOrThrow(i),s=void 0===s?r:Sk.misceval.asIndexOrThrow(s),this.head),a=this.mask,l=this.v;s=0<=s?s:s<-r?0:r+s;for(let t=0<=i?i:i<-r?0:r+i;t<s;t++)if(l[n+t&a]===e)return t},sk$asarray(){var e=[],i=this.tail-this.head&this.mask;for(let t=0;t<i;++t){var s=this.head+t&this.mask;e.push(this.v[s])}return e}}});const i=Sk.abstr.buildIteratorClass("_collections._deque_iterator",{constructor:function(t){this.$index=0,this.dq=t.v,this.$length=t.tail-t.head&t.mask,this.$head=t.head,this.$tail=t.tail,this.$mask=t.mask},iternext(){var t;if(!(this.$index>=this.$length))return t=(0<=this.$index?this.$head:this.$tail)+this.$index&this.$mask,this.$index++,this.dq[t]},methods:{__length_hint__:{$meth:function(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),s=Sk.abstr.buildIteratorClass("_collections._deque_reverse_iterator",{constructor:function(t){this.$index=(t.tail-t.head&t.mask)-1,this.dq=t.v,this.$head=t.head,this.$mask=t.mask},iternext(){var t;if(!(this.$index<0))return t=this.$head+this.$index&this.$mask,this.$index--,this.dq[t]},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),k=new RegExp(/^[0-9].*/),b=new RegExp(/^[0-9_].*/),f=new RegExp(/^\w*$/),v=/,/g,S=/\s+/;function r(t,i,e,s,r){if(t=t.tp$str(),Sk.misceval.isTrue(Sk.misceval.callsimArray($._iskeyword,[t])))throw new Sk.builtin.ValueError("Type names and field names cannot be a keyword: '"+Sk.misceval.objectRepr(t)+"'");t=t.$jsstr();if(k.test(t)||!f.test(t)||!t)throw new Sk.builtin.ValueError("Type names and field names must be valid identifiers: '"+t+"'");let n,a;if(Sk.builtin.checkString(i))1==(n=i.$jsstr().replace(v," ").split(S)).length&&""===n[0]&&(n=[]),a=n.map(t=>new Sk.builtin.str(t));else{n=[],a=[];for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())e=e.tp$str(),a.push(e),n.push(e.$jsstr())}var l=new Set;if(Sk.misceval.isTrue(e))for(let t=0;t<n.length;t++)!Sk.misceval.isTrue(Sk.misceval.callsimArray($._iskeyword,[a[t]]))&&!b.test(n[t])&&f.test(n[t])&&n[t]&&!l.has(n[t])||(n[t]="_"+t,a[t]=new Sk.builtin.str("_"+t)),l.add(n[t]);else for(let t=0;t<n.length;t++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray($._iskeyword,[a[t]])))throw new Sk.builtin.ValueError("Type names and field names cannot be a keyword: '"+n[t]+"'");if(b.test(n[t]))throw new Sk.builtin.ValueError("Field names cannot start with an underscore: '"+n[t]+"'");if(!f.test(n[t])||!n[t])throw new Sk.builtin.ValueError("Type names and field names must be valid identifiers: '"+n[t]+"'");if(l.has(n[t]))throw new Sk.builtin.ValueError("Encountered duplicate field name: '"+n[t]+"'");l.add(n[t])}const o=new Sk.builtin.tuple(a);var h=[];let u=[];if(!Sk.builtin.checkNone(s)){if((u=Sk.misceval.arrayFromIterable(s)).length>n.length)throw new Sk.builtin.TypeError("Got more default values than field names");for(let t=0,e=a.length-u.length;e<a.length;t++,e++)h.push(a[e]),h.push(u[t])}i=new Sk.builtin.dict(h);function c(t,e){return t.prototype.tp$new(Sk.misceval.arrayFromIterable(e))}function m(e){var i=[];for(let t=0;t<e._fields.v.length;t++)i.push(e._fields.v[t]),i.push(e.v[t]);return new Sk.builtin.dict(i)}function d(t,e){var i=(t=new Sk.builtin.dict(t)).tp$getattr(new Sk.builtin.str("pop")),s=Sk.abstr.gattr(e,new Sk.builtin.str("_make")),r=Sk.misceval.callsimArray,s=r(s,[r(Sk.builtin.map_,[i,o,e])]);if(t.sq$length())throw r=t.sk$asarray(),new Sk.builtin.ValueError("Got unexpectd field names: ["+r.map(t=>"'"+t.$jsstr()+"'")+"]");return s}c.co_varnames=["_cls","iterable"],m.co_varnames=["self"],d.co_kwargs=1,d.co_varnames=["_self"];var p={};for(let t=0;t<n.length;t++)p[a[t].$mangled]=new Sk.builtin.property(new $._itemgetter([new Sk.builtin.int_(t)]),void 0,void 0,new Sk.builtin.str("Alias for field number "+t));return Sk.abstr.buildNativeClass(t,{constructor:function(){},base:Sk.builtin.tuple,slots:{tp$doc:t+"("+n.join(", ")+")",tp$new(t,e){t=Sk.abstr.copyKeywordsToNamedArgs("__new__",n,t,e,u);e=new this.constructor;return Sk.builtin.tuple.call(e,t),e},$r(){var t=this.v.map((t,e)=>n[e]+"="+Sk.misceval.objectRepr(t));return new Sk.builtin.str(Sk.abstr.typeName(this)+"("+t.join(", ")+")")}},flags:{sk$klass:!0},proto:Object.assign({__module__:Sk.builtin.checkNone(r)?Sk.globals.__name__:r,__slots__:new Sk.builtin.tuple,_fields:o,_field_defaults:i,_make:new Sk.builtin.classmethod(new Sk.builtin.func(c)),_asdict:new Sk.builtin.func(m),_replace:new Sk.builtin.func(d)},p)})}return r.co_argcount=2,r.co_kwonlyargcount=3,r.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$],r.co_varnames=["typename","field_names","rename","defaults","module"],$.namedtuple=new Sk.builtin.func(r),$}